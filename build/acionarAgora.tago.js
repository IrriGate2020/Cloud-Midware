/*
 * TagoIO (https://tago.io/)
 * TagoIO Builder V3.0.3 (https://git.io/JJ8Si)
 * -------------------
 * Generated by     :: rafael
 * Generated at     :: Friday, December 20, 2024 at 11:08 AM Coordinated Universal Time
 * Machine          :: Rafael <linux> - Node.js v20.18.0
 * Origin file      :: src/analysis/sendCommandNowNew.ts <Typescript>
 * Destination file :: ./build/acionarAgora.tago.js
 * -------------------
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/mqtt/build/lib/topic-alias-recv.js
var require_topic_alias_recv = __commonJS({
  "node_modules/mqtt/build/lib/topic-alias-recv.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TopicAliasRecv = class {
      constructor(max) {
        this.aliasToTopic = {};
        this.max = max;
      }
      put(topic, alias) {
        if (alias === 0 || alias > this.max) {
          return false;
        }
        this.aliasToTopic[alias] = topic;
        this.length = Object.keys(this.aliasToTopic).length;
        return true;
      }
      getTopicByAlias(alias) {
        return this.aliasToTopic[alias];
      }
      clear() {
        this.aliasToTopic = {};
      }
    };
    exports.default = TopicAliasRecv;
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(retv != null, "'this' is expected an Event object, but got", event);
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      get type() {
        return pd(this).event.type;
      },
      get target() {
        return pd(this).eventTarget;
      },
      get currentTarget() {
        return pd(this).currentTarget;
      },
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      get NONE() {
        return 0;
      },
      get CAPTURING_PHASE() {
        return 1;
      },
      get AT_TARGET() {
        return 2;
      },
      get BUBBLING_PHASE() {
        return 3;
      },
      get eventPhase() {
        return pd(this).eventPhase;
      },
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      preventDefault() {
        setCancelFlag(pd(this));
      },
      get defaultPrevented() {
        return pd(this).canceled;
      },
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      get timeStamp() {
        return pd(this).timeStamp;
      },
      get srcElement() {
        return pd(this).eventTarget;
      },
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController;
    module2.exports = AbortController;
    module2.exports.AbortController = module2.exports["default"] = AbortController;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var { kResistStopPropagation, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal;
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require("events").addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener("abort", () => {
          signals.forEach((signal) => signal.removeEventListener("abort", abort));
        }, {
          once: true
        });
        return ac.signal;
      }
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module2) {
    "use strict";
    var { format, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      assert(typeof name === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      let msg = "The ";
      if (name.endsWith(" argument")) {
        msg += `${name} `;
      } else {
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      }
      msg += "must be ";
      const types = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        assert(typeof value === "string", "All expected entries have to be of type string");
        if (kTypes.includes(value)) {
          types.push(value.toLowerCase());
        } else if (classRegExp.test(value)) {
          instances.push(value);
        } else {
          assert(value !== "object", 'The value "object" should be written as "Object"');
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
          types.splice(types, pos, 1);
          instances.push("Object");
        }
      }
      if (types.length > 0) {
        switch (types.length) {
          case 1:
            msg += `of type ${types[0]}`;
            break;
          case 2:
            msg += `one of type ${types[0]} or ${types[1]}`;
            break;
          default: {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null) {
        msg += `. Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += `. Received function ${actual.name}`;
      } else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
          msg += `. Received an instance of ${actual.constructor.name}`;
        } else {
          const inspected = inspect(actual, {
            depth: -1
          });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect(actual, {
          colors: false
        });
        if (inspected.length > 25) {
          inspected = `${inspected.slice(0, 25)}...`;
        }
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
      let inspected = inspect(value);
      if (inspected.length > 128) {
        inspected = inspected.slice(0, 128) + "...";
      }
      const type = name.includes(".") ? "property" : "argument";
      return `The ${type} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
      var _value$constructor;
      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
    }, TypeError);
    E("ERR_MISSING_ARGS", (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg;
      const len = args.length;
      args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
      switch (len) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            const last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > 2n ** 32n || input < -(2n ** 32n)) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      } else {
        received = inspect(input);
      }
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/index.js
var require_process = __commonJS({
  "node_modules/process/index.js"(exports, module2) {
    module2.exports = global.process;
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module2) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    var process2 = require_process();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module2) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError(void 0, {
          cause: signal.reason
        }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError(void 0, {
          cause: signal.reason
        }));
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { inspect } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          depth: 0,
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require("string_decoder");
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      constructed: makeBitMapDescriptor(kConstructed),
      sync: makeBitMapDescriptor(kSync),
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      destroyed: makeBitMapDescriptor(kDestroyed),
      closed: makeBitMapDescriptor(kClosed),
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(stream, {
        writable: false
      }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null;
        callback();
        callback = nop;
      });
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev([
          {
            chunk,
            encoding
          }
        ], cb);
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick((stream2, state2) => {
              if (needFinish(state2)) {
                finish(stream2, state2);
              } else {
                state2.pendingcb--;
              }
            }, stream, state);
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module2) {
    var process2 = require_process();
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null) {
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }
          }, (err) => {
            destroyer(d, err);
          });
          return d = new Duplexify({
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(then, body, (val) => {
          if (val != null) {
            d.push(val);
          }
          d.push(null);
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(name, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ], body);
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(async function* () {
        while (true) {
          const _promise = promise;
          promise = null;
          const { chunk, done, cb } = await _promise;
          process2.nextTick(cb);
          if (done)
            return;
          if (signal.aborted)
            throw new AbortError(void 0, {
              cause: signal.reason
            });
          ({ promise, resolve } = createDeferredPromise());
          yield chunk;
        }
      }(), {
        signal
      });
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    var process2 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        finished = !err;
      });
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(writable, {
        readable: false
      }, resume);
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(ret, (val) => {
                value = val;
                if (val != null) {
                  pt.write(val);
                }
                if (end) {
                  pt.end();
                }
                process2.nextTick(finish);
              }, (err) => {
                pt.destroy(err);
                process2.nextTick(finish, err);
              });
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(src, {
        readable: true,
        writable: false
      }, (err) => {
        const rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
          src.once("end", finish).once("error", finish);
        } else {
          finish(err);
        }
      });
      return eos(dst, {
        readable: false,
        writable: true
      }, finish);
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module2) {
    "use strict";
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = require_util().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2));
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options);
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(streams, (err, value) => {
          if (err) {
            reject(err);
          } else {
            resolve(value);
          }
        }, {
          signal,
          end
        });
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module2) {
    var { Buffer: Buffer2 } = require("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "node_modules/readable-stream/lib/ours/index.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module2) {
    "use strict";
    var DuplexStream = require_ours().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/mqtt-packet/packet.js
var require_packet = __commonJS({
  "node_modules/mqtt-packet/packet.js"(exports, module2) {
    var Packet = class {
      constructor() {
        this.cmd = null;
        this.retain = false;
        this.qos = 0;
        this.dup = false;
        this.length = -1;
        this.topic = null;
        this.payload = null;
      }
    };
    module2.exports = Packet;
  }
});

// node_modules/mqtt-packet/constants.js
var require_constants = __commonJS({
  "node_modules/mqtt-packet/constants.js"(exports, module2) {
    var protocol = module2.exports;
    var { Buffer: Buffer2 } = require("buffer");
    protocol.types = {
      0: "reserved",
      1: "connect",
      2: "connack",
      3: "publish",
      4: "puback",
      5: "pubrec",
      6: "pubrel",
      7: "pubcomp",
      8: "subscribe",
      9: "suback",
      10: "unsubscribe",
      11: "unsuback",
      12: "pingreq",
      13: "pingresp",
      14: "disconnect",
      15: "auth"
    };
    protocol.requiredHeaderFlags = {
      1: 0,
      2: 0,
      4: 0,
      5: 0,
      6: 2,
      7: 0,
      8: 2,
      9: 0,
      10: 2,
      11: 0,
      12: 0,
      13: 0,
      14: 0,
      15: 0
    };
    protocol.requiredHeaderFlagsErrors = {};
    for (const k in protocol.requiredHeaderFlags) {
      const v = protocol.requiredHeaderFlags[k];
      protocol.requiredHeaderFlagsErrors[k] = "Invalid header flag bits, must be 0x" + v.toString(16) + " for " + protocol.types[k] + " packet";
    }
    protocol.codes = {};
    for (const k in protocol.types) {
      const v = protocol.types[k];
      protocol.codes[v] = k;
    }
    protocol.CMD_SHIFT = 4;
    protocol.CMD_MASK = 240;
    protocol.DUP_MASK = 8;
    protocol.QOS_MASK = 3;
    protocol.QOS_SHIFT = 1;
    protocol.RETAIN_MASK = 1;
    protocol.VARBYTEINT_MASK = 127;
    protocol.VARBYTEINT_FIN_MASK = 128;
    protocol.VARBYTEINT_MAX = 268435455;
    protocol.SESSIONPRESENT_MASK = 1;
    protocol.SESSIONPRESENT_HEADER = Buffer2.from([protocol.SESSIONPRESENT_MASK]);
    protocol.CONNACK_HEADER = Buffer2.from([protocol.codes.connack << protocol.CMD_SHIFT]);
    protocol.USERNAME_MASK = 128;
    protocol.PASSWORD_MASK = 64;
    protocol.WILL_RETAIN_MASK = 32;
    protocol.WILL_QOS_MASK = 24;
    protocol.WILL_QOS_SHIFT = 3;
    protocol.WILL_FLAG_MASK = 4;
    protocol.CLEAN_SESSION_MASK = 2;
    protocol.CONNECT_HEADER = Buffer2.from([protocol.codes.connect << protocol.CMD_SHIFT]);
    protocol.properties = {
      sessionExpiryInterval: 17,
      willDelayInterval: 24,
      receiveMaximum: 33,
      maximumPacketSize: 39,
      topicAliasMaximum: 34,
      requestResponseInformation: 25,
      requestProblemInformation: 23,
      userProperties: 38,
      authenticationMethod: 21,
      authenticationData: 22,
      payloadFormatIndicator: 1,
      messageExpiryInterval: 2,
      contentType: 3,
      responseTopic: 8,
      correlationData: 9,
      maximumQoS: 36,
      retainAvailable: 37,
      assignedClientIdentifier: 18,
      reasonString: 31,
      wildcardSubscriptionAvailable: 40,
      subscriptionIdentifiersAvailable: 41,
      sharedSubscriptionAvailable: 42,
      serverKeepAlive: 19,
      responseInformation: 26,
      serverReference: 28,
      topicAlias: 35,
      subscriptionIdentifier: 11
    };
    protocol.propertiesCodes = {};
    for (const prop in protocol.properties) {
      const id = protocol.properties[prop];
      protocol.propertiesCodes[id] = prop;
    }
    protocol.propertiesTypes = {
      sessionExpiryInterval: "int32",
      willDelayInterval: "int32",
      receiveMaximum: "int16",
      maximumPacketSize: "int32",
      topicAliasMaximum: "int16",
      requestResponseInformation: "byte",
      requestProblemInformation: "byte",
      userProperties: "pair",
      authenticationMethod: "string",
      authenticationData: "binary",
      payloadFormatIndicator: "byte",
      messageExpiryInterval: "int32",
      contentType: "string",
      responseTopic: "string",
      correlationData: "binary",
      maximumQoS: "int8",
      retainAvailable: "byte",
      assignedClientIdentifier: "string",
      reasonString: "string",
      wildcardSubscriptionAvailable: "byte",
      subscriptionIdentifiersAvailable: "byte",
      sharedSubscriptionAvailable: "byte",
      serverKeepAlive: "int16",
      responseInformation: "string",
      serverReference: "string",
      topicAlias: "int16",
      subscriptionIdentifier: "var"
    };
    function genHeader(type) {
      return [0, 1, 2].map((qos) => {
        return [0, 1].map((dup) => {
          return [0, 1].map((retain) => {
            const buf = Buffer2.alloc(1);
            buf.writeUInt8(protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain, 0, true);
            return buf;
          });
        });
      });
    }
    protocol.PUBLISH_HEADER = genHeader("publish");
    protocol.SUBSCRIBE_HEADER = genHeader("subscribe");
    protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_NL_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
    protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
    protocol.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
    protocol.SUBSCRIBE_OPTIONS_NL = 4;
    protocol.SUBSCRIBE_OPTIONS_RAP = 8;
    protocol.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
    protocol.UNSUBSCRIBE_HEADER = genHeader("unsubscribe");
    protocol.ACKS = {
      unsuback: genHeader("unsuback"),
      puback: genHeader("puback"),
      pubcomp: genHeader("pubcomp"),
      pubrel: genHeader("pubrel"),
      pubrec: genHeader("pubrec")
    };
    protocol.SUBACK_HEADER = Buffer2.from([protocol.codes.suback << protocol.CMD_SHIFT]);
    protocol.VERSION3 = Buffer2.from([3]);
    protocol.VERSION4 = Buffer2.from([4]);
    protocol.VERSION5 = Buffer2.from([5]);
    protocol.VERSION131 = Buffer2.from([131]);
    protocol.VERSION132 = Buffer2.from([132]);
    protocol.QOS = [0, 1, 2].map((qos) => {
      return Buffer2.from([qos]);
    });
    protocol.EMPTY = {
      pingreq: Buffer2.from([protocol.codes.pingreq << 4, 0]),
      pingresp: Buffer2.from([protocol.codes.pingresp << 4, 0]),
      disconnect: Buffer2.from([protocol.codes.disconnect << 4, 0])
    };
    protocol.MQTT5_PUBACK_PUBREC_CODES = {
      0: "Success",
      16: "No matching subscribers",
      128: "Unspecified error",
      131: "Implementation specific error",
      135: "Not authorized",
      144: "Topic Name invalid",
      145: "Packet identifier in use",
      151: "Quota exceeded",
      153: "Payload format invalid"
    };
    protocol.MQTT5_PUBREL_PUBCOMP_CODES = {
      0: "Success",
      146: "Packet Identifier not found"
    };
    protocol.MQTT5_SUBACK_CODES = {
      0: "Granted QoS 0",
      1: "Granted QoS 1",
      2: "Granted QoS 2",
      128: "Unspecified error",
      131: "Implementation specific error",
      135: "Not authorized",
      143: "Topic Filter invalid",
      145: "Packet Identifier in use",
      151: "Quota exceeded",
      158: "Shared Subscriptions not supported",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    protocol.MQTT5_UNSUBACK_CODES = {
      0: "Success",
      17: "No subscription existed",
      128: "Unspecified error",
      131: "Implementation specific error",
      135: "Not authorized",
      143: "Topic Filter invalid",
      145: "Packet Identifier in use"
    };
    protocol.MQTT5_DISCONNECT_CODES = {
      0: "Normal disconnection",
      4: "Disconnect with Will Message",
      128: "Unspecified error",
      129: "Malformed Packet",
      130: "Protocol Error",
      131: "Implementation specific error",
      135: "Not authorized",
      137: "Server busy",
      139: "Server shutting down",
      141: "Keep Alive timeout",
      142: "Session taken over",
      143: "Topic Filter invalid",
      144: "Topic Name invalid",
      147: "Receive Maximum exceeded",
      148: "Topic Alias invalid",
      149: "Packet too large",
      150: "Message rate too high",
      151: "Quota exceeded",
      152: "Administrative action",
      153: "Payload format invalid",
      154: "Retain not supported",
      155: "QoS not supported",
      156: "Use another server",
      157: "Server moved",
      158: "Shared Subscriptions not supported",
      159: "Connection rate exceeded",
      160: "Maximum connect time",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    protocol.MQTT5_AUTH_CODES = {
      0: "Success",
      24: "Continue authentication",
      25: "Re-authenticate"
    };
  }
});

// node_modules/mqtt-packet/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/mqtt-packet/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/mqtt-packet/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/mqtt-packet/node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/mqtt-packet/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/mqtt-packet/node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/mqtt-packet/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/mqtt-packet/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/mqtt-packet/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/mqtt-packet/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/mqtt-packet/parser.js
var require_parser = __commonJS({
  "node_modules/mqtt-packet/parser.js"(exports, module2) {
    var bl = require_bl();
    var { EventEmitter } = require("events");
    var Packet = require_packet();
    var constants = require_constants();
    var debug = require_src()("mqtt-packet:parser");
    var Parser = class extends EventEmitter {
      constructor() {
        super();
        this.parser = this.constructor.parser;
      }
      static parser(opt) {
        if (!(this instanceof Parser))
          return new Parser().parser(opt);
        this.settings = opt || {};
        this._states = [
          "_parseHeader",
          "_parseLength",
          "_parsePayload",
          "_newPacket"
        ];
        this._resetState();
        return this;
      }
      _resetState() {
        debug("_resetState: resetting packet, error, _list, and _stateCounter");
        this.packet = new Packet();
        this.error = null;
        this._list = bl();
        this._stateCounter = 0;
      }
      parse(buf) {
        if (this.error)
          this._resetState();
        this._list.append(buf);
        debug("parse: current state: %s", this._states[this._stateCounter]);
        while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {
          this._stateCounter++;
          debug("parse: state complete. _stateCounter is now: %d", this._stateCounter);
          debug("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length);
          if (this._stateCounter >= this._states.length)
            this._stateCounter = 0;
        }
        debug("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length);
        return this._list.length;
      }
      _parseHeader() {
        const zero = this._list.readUInt8(0);
        const cmdIndex = zero >> constants.CMD_SHIFT;
        this.packet.cmd = constants.types[cmdIndex];
        const headerFlags = zero & 15;
        const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex];
        if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {
          return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]));
        }
        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;
        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;
        if (this.packet.qos > 2) {
          return this._emitError(new Error("Packet must not have both QoS bits set to 1"));
        }
        this.packet.dup = (zero & constants.DUP_MASK) !== 0;
        debug("_parseHeader: packet: %o", this.packet);
        this._list.consume(1);
        return true;
      }
      _parseLength() {
        const result = this._parseVarByteNum(true);
        if (result) {
          this.packet.length = result.value;
          this._list.consume(result.bytes);
        }
        debug("_parseLength %d", result.value);
        return !!result;
      }
      _parsePayload() {
        debug("_parsePayload: payload %O", this._list);
        let result = false;
        if (this.packet.length === 0 || this._list.length >= this.packet.length) {
          this._pos = 0;
          switch (this.packet.cmd) {
            case "connect":
              this._parseConnect();
              break;
            case "connack":
              this._parseConnack();
              break;
            case "publish":
              this._parsePublish();
              break;
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              this._parseConfirmation();
              break;
            case "subscribe":
              this._parseSubscribe();
              break;
            case "suback":
              this._parseSuback();
              break;
            case "unsubscribe":
              this._parseUnsubscribe();
              break;
            case "unsuback":
              this._parseUnsuback();
              break;
            case "pingreq":
            case "pingresp":
              break;
            case "disconnect":
              this._parseDisconnect();
              break;
            case "auth":
              this._parseAuth();
              break;
            default:
              this._emitError(new Error("Not supported"));
          }
          result = true;
        }
        debug("_parsePayload complete result: %s", result);
        return result;
      }
      _parseConnect() {
        debug("_parseConnect");
        let topic;
        let payload;
        let password;
        let username;
        const flags = {};
        const packet = this.packet;
        const protocolId = this._parseString();
        if (protocolId === null)
          return this._emitError(new Error("Cannot parse protocolId"));
        if (protocolId !== "MQTT" && protocolId !== "MQIsdp") {
          return this._emitError(new Error("Invalid protocolId"));
        }
        packet.protocolId = protocolId;
        if (this._pos >= this._list.length)
          return this._emitError(new Error("Packet too short"));
        packet.protocolVersion = this._list.readUInt8(this._pos);
        if (packet.protocolVersion >= 128) {
          packet.bridgeMode = true;
          packet.protocolVersion = packet.protocolVersion - 128;
        }
        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
          return this._emitError(new Error("Invalid protocol version"));
        }
        this._pos++;
        if (this._pos >= this._list.length) {
          return this._emitError(new Error("Packet too short"));
        }
        if (this._list.readUInt8(this._pos) & 1) {
          return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
        }
        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;
        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;
        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;
        const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK);
        const willQos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;
        if (flags.will) {
          packet.will = {};
          packet.will.retain = willRetain;
          packet.will.qos = willQos;
        } else {
          if (willRetain) {
            return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
          }
          if (willQos) {
            return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
          }
        }
        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;
        this._pos++;
        packet.keepalive = this._parseNum();
        if (packet.keepalive === -1)
          return this._emitError(new Error("Packet too short"));
        if (packet.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        const clientId2 = this._parseString();
        if (clientId2 === null)
          return this._emitError(new Error("Packet too short"));
        packet.clientId = clientId2;
        debug("_parseConnect: packet.clientId: %s", packet.clientId);
        if (flags.will) {
          if (packet.protocolVersion === 5) {
            const willProperties = this._parseProperties();
            if (Object.getOwnPropertyNames(willProperties).length) {
              packet.will.properties = willProperties;
            }
          }
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse will topic"));
          packet.will.topic = topic;
          debug("_parseConnect: packet.will.topic: %s", packet.will.topic);
          payload = this._parseBuffer();
          if (payload === null)
            return this._emitError(new Error("Cannot parse will payload"));
          packet.will.payload = payload;
          debug("_parseConnect: packet.will.paylaod: %s", packet.will.payload);
        }
        if (flags.username) {
          username = this._parseString();
          if (username === null)
            return this._emitError(new Error("Cannot parse username"));
          packet.username = username;
          debug("_parseConnect: packet.username: %s", packet.username);
        }
        if (flags.password) {
          password = this._parseBuffer();
          if (password === null)
            return this._emitError(new Error("Cannot parse password"));
          packet.password = password;
        }
        this.settings = packet;
        debug("_parseConnect: complete");
        return packet;
      }
      _parseConnack() {
        debug("_parseConnack");
        const packet = this.packet;
        if (this._list.length < 1)
          return null;
        const flags = this._list.readUInt8(this._pos++);
        if (flags > 1) {
          return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
        }
        packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK);
        if (this.settings.protocolVersion === 5) {
          if (this._list.length >= 2) {
            packet.reasonCode = this._list.readUInt8(this._pos++);
          } else {
            packet.reasonCode = 0;
          }
        } else {
          if (this._list.length < 2)
            return null;
          packet.returnCode = this._list.readUInt8(this._pos++);
        }
        if (packet.returnCode === -1 || packet.reasonCode === -1)
          return this._emitError(new Error("Cannot parse return code"));
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseConnack: complete");
      }
      _parsePublish() {
        debug("_parsePublish");
        const packet = this.packet;
        packet.topic = this._parseString();
        if (packet.topic === null)
          return this._emitError(new Error("Cannot parse topic"));
        if (packet.qos > 0) {
          if (!this._parseMessageId()) {
            return;
          }
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        packet.payload = this._list.slice(this._pos, packet.length);
        debug("_parsePublish: payload from buffer list: %o", packet.payload);
      }
      _parseSubscribe() {
        debug("_parseSubscribe");
        const packet = this.packet;
        let topic;
        let options;
        let qos;
        let rh;
        let rap;
        let nl;
        let subscription;
        packet.subscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        if (packet.length <= 0) {
          return this._emitError(new Error("Malformed subscribe, no payload specified"));
        }
        while (this._pos < packet.length) {
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          if (this._pos >= packet.length)
            return this._emitError(new Error("Malformed Subscribe Payload"));
          options = this._parseByte();
          if (this.settings.protocolVersion === 5) {
            if (options & 192) {
              return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
            }
          } else {
            if (options & 252) {
              return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
            }
          }
          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;
          if (qos > 2) {
            return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
          }
          nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;
          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;
          rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;
          if (rh > 2) {
            return this._emitError(new Error("Invalid retain handling, must be <= 2"));
          }
          subscription = { topic, qos };
          if (this.settings.protocolVersion === 5) {
            subscription.nl = nl;
            subscription.rap = rap;
            subscription.rh = rh;
          } else if (this.settings.bridgeMode) {
            subscription.rh = 0;
            subscription.rap = true;
            subscription.nl = true;
          }
          debug("_parseSubscribe: push subscription `%s` to subscription", subscription);
          packet.subscriptions.push(subscription);
        }
      }
      _parseSuback() {
        debug("_parseSuback");
        const packet = this.packet;
        this.packet.granted = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        if (packet.length <= 0) {
          return this._emitError(new Error("Malformed suback, no payload specified"));
        }
        while (this._pos < this.packet.length) {
          const code = this._list.readUInt8(this._pos++);
          if (this.settings.protocolVersion === 5) {
            if (!constants.MQTT5_SUBACK_CODES[code]) {
              return this._emitError(new Error("Invalid suback code"));
            }
          } else {
            if (code > 2 && code !== 128) {
              return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
            }
          }
          this.packet.granted.push(code);
        }
      }
      _parseUnsubscribe() {
        debug("_parseUnsubscribe");
        const packet = this.packet;
        packet.unsubscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        if (packet.length <= 0) {
          return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
        }
        while (this._pos < packet.length) {
          const topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          debug("_parseUnsubscribe: push topic `%s` to unsubscriptions", topic);
          packet.unsubscriptions.push(topic);
        }
      }
      _parseUnsuback() {
        debug("_parseUnsuback");
        const packet = this.packet;
        if (!this._parseMessageId())
          return this._emitError(new Error("Cannot parse messageId"));
        if ((this.settings.protocolVersion === 3 || this.settings.protocolVersion === 4) && packet.length !== 2) {
          return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
        }
        if (packet.length <= 0) {
          return this._emitError(new Error("Malformed unsuback, no payload specified"));
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
          packet.granted = [];
          while (this._pos < this.packet.length) {
            const code = this._list.readUInt8(this._pos++);
            if (!constants.MQTT5_UNSUBACK_CODES[code]) {
              return this._emitError(new Error("Invalid unsuback code"));
            }
            this.packet.granted.push(code);
          }
        }
      }
      _parseConfirmation() {
        debug("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
        const packet = this.packet;
        this._parseMessageId();
        if (this.settings.protocolVersion === 5) {
          if (packet.length > 2) {
            packet.reasonCode = this._parseByte();
            switch (this.packet.cmd) {
              case "puback":
              case "pubrec":
                if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {
                  return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                }
                break;
              case "pubrel":
              case "pubcomp":
                if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {
                  return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                }
                break;
            }
            debug("_parseConfirmation: packet.reasonCode `%d`", packet.reasonCode);
          } else {
            packet.reasonCode = 0;
          }
          if (packet.length > 3) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
        }
        return true;
      }
      _parseDisconnect() {
        const packet = this.packet;
        debug("_parseDisconnect");
        if (this.settings.protocolVersion === 5) {
          if (this._list.length > 0) {
            packet.reasonCode = this._parseByte();
            if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {
              this._emitError(new Error("Invalid disconnect reason code"));
            }
          } else {
            packet.reasonCode = 0;
          }
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseDisconnect result: true");
        return true;
      }
      _parseAuth() {
        debug("_parseAuth");
        const packet = this.packet;
        if (this.settings.protocolVersion !== 5) {
          return this._emitError(new Error("Not supported auth packet for this version MQTT"));
        }
        packet.reasonCode = this._parseByte();
        if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {
          return this._emitError(new Error("Invalid auth reason code"));
        }
        const properties = this._parseProperties();
        if (Object.getOwnPropertyNames(properties).length) {
          packet.properties = properties;
        }
        debug("_parseAuth: result: true");
        return true;
      }
      _parseMessageId() {
        const packet = this.packet;
        packet.messageId = this._parseNum();
        if (packet.messageId === null) {
          this._emitError(new Error("Cannot parse messageId"));
          return false;
        }
        debug("_parseMessageId: packet.messageId %d", packet.messageId);
        return true;
      }
      _parseString(maybeBuffer) {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.toString("utf8", this._pos, end);
        this._pos += length;
        debug("_parseString: result: %s", result);
        return result;
      }
      _parseStringPair() {
        debug("_parseStringPair");
        return {
          name: this._parseString(),
          value: this._parseString()
        };
      }
      _parseBuffer() {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.slice(this._pos, end);
        this._pos += length;
        debug("_parseBuffer: result: %o", result);
        return result;
      }
      _parseNum() {
        if (this._list.length - this._pos < 2)
          return -1;
        const result = this._list.readUInt16BE(this._pos);
        this._pos += 2;
        debug("_parseNum: result: %s", result);
        return result;
      }
      _parse4ByteNum() {
        if (this._list.length - this._pos < 4)
          return -1;
        const result = this._list.readUInt32BE(this._pos);
        this._pos += 4;
        debug("_parse4ByteNum: result: %s", result);
        return result;
      }
      _parseVarByteNum(fullInfoFlag) {
        debug("_parseVarByteNum");
        const maxBytes = 4;
        let bytes = 0;
        let mul = 1;
        let value = 0;
        let result = false;
        let current;
        const padding = this._pos ? this._pos : 0;
        while (bytes < maxBytes && padding + bytes < this._list.length) {
          current = this._list.readUInt8(padding + bytes++);
          value += mul * (current & constants.VARBYTEINT_MASK);
          mul *= 128;
          if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
            result = true;
            break;
          }
          if (this._list.length <= bytes) {
            break;
          }
        }
        if (!result && bytes === maxBytes && this._list.length >= bytes) {
          this._emitError(new Error("Invalid variable byte integer"));
        }
        if (padding) {
          this._pos += bytes;
        }
        if (result) {
          if (fullInfoFlag) {
            result = { bytes, value };
          } else {
            result = value;
          }
        } else {
          result = false;
        }
        debug("_parseVarByteNum: result: %o", result);
        return result;
      }
      _parseByte() {
        let result;
        if (this._pos < this._list.length) {
          result = this._list.readUInt8(this._pos);
          this._pos++;
        }
        debug("_parseByte: result: %o", result);
        return result;
      }
      _parseByType(type) {
        debug("_parseByType: type: %s", type);
        switch (type) {
          case "byte": {
            return this._parseByte() !== 0;
          }
          case "int8": {
            return this._parseByte();
          }
          case "int16": {
            return this._parseNum();
          }
          case "int32": {
            return this._parse4ByteNum();
          }
          case "var": {
            return this._parseVarByteNum();
          }
          case "string": {
            return this._parseString();
          }
          case "pair": {
            return this._parseStringPair();
          }
          case "binary": {
            return this._parseBuffer();
          }
        }
      }
      _parseProperties() {
        debug("_parseProperties");
        const length = this._parseVarByteNum();
        const start = this._pos;
        const end = start + length;
        const result = {};
        while (this._pos < end) {
          const type = this._parseByte();
          if (!type) {
            this._emitError(new Error("Cannot parse property code type"));
            return false;
          }
          const name = constants.propertiesCodes[type];
          if (!name) {
            this._emitError(new Error("Unknown property"));
            return false;
          }
          if (name === "userProperties") {
            if (!result[name]) {
              result[name] = /* @__PURE__ */ Object.create(null);
            }
            const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);
            if (result[name][currentUserProperty.name]) {
              if (Array.isArray(result[name][currentUserProperty.name])) {
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              } else {
                const currentValue = result[name][currentUserProperty.name];
                result[name][currentUserProperty.name] = [currentValue];
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              }
            } else {
              result[name][currentUserProperty.name] = currentUserProperty.value;
            }
            continue;
          }
          if (result[name]) {
            if (Array.isArray(result[name])) {
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            } else {
              result[name] = [result[name]];
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            }
          } else {
            result[name] = this._parseByType(constants.propertiesTypes[name]);
          }
        }
        return result;
      }
      _newPacket() {
        debug("_newPacket");
        if (this.packet) {
          this._list.consume(this.packet.length);
          debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length);
          this.emit("packet", this.packet);
        }
        debug("_newPacket: new packet");
        this.packet = new Packet();
        this._pos = 0;
        return true;
      }
      _emitError(err) {
        debug("_emitError", err);
        this.error = err;
        this.emit("error", err);
      }
    };
    module2.exports = Parser;
  }
});

// node_modules/mqtt-packet/numbers.js
var require_numbers = __commonJS({
  "node_modules/mqtt-packet/numbers.js"(exports, module2) {
    var { Buffer: Buffer2 } = require("buffer");
    var max = 65536;
    var cache = {};
    var SubOk = Buffer2.isBuffer(Buffer2.from([1, 2]).subarray(0, 1));
    function generateBuffer(i) {
      const buffer = Buffer2.allocUnsafe(2);
      buffer.writeUInt8(i >> 8, 0);
      buffer.writeUInt8(i & 255, 0 + 1);
      return buffer;
    }
    function generateCache() {
      for (let i = 0; i < max; i++) {
        cache[i] = generateBuffer(i);
      }
    }
    function genBufVariableByteInt(num) {
      const maxLength = 4;
      let digit = 0;
      let pos = 0;
      const buffer = Buffer2.allocUnsafe(maxLength);
      do {
        digit = num % 128 | 0;
        num = num / 128 | 0;
        if (num > 0)
          digit = digit | 128;
        buffer.writeUInt8(digit, pos++);
      } while (num > 0 && pos < maxLength);
      if (num > 0) {
        pos = 0;
      }
      return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);
    }
    function generate4ByteBuffer(num) {
      const buffer = Buffer2.allocUnsafe(4);
      buffer.writeUInt32BE(num, 0);
      return buffer;
    }
    module2.exports = {
      cache,
      generateCache,
      generateNumber: generateBuffer,
      genBufVariableByteInt,
      generate4ByteBuffer
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/mqtt-packet/writeToStream.js
var require_writeToStream = __commonJS({
  "node_modules/mqtt-packet/writeToStream.js"(exports, module2) {
    var protocol = require_constants();
    var { Buffer: Buffer2 } = require("buffer");
    var empty = Buffer2.allocUnsafe(0);
    var zeroBuf = Buffer2.from([0]);
    var numbers = require_numbers();
    var nextTick = require_process_nextick_args().nextTick;
    var debug = require_src()("mqtt-packet:writeToStream");
    var numCache = numbers.cache;
    var generateNumber = numbers.generateNumber;
    var generateCache = numbers.generateCache;
    var genBufVariableByteInt = numbers.genBufVariableByteInt;
    var generate4ByteBuffer = numbers.generate4ByteBuffer;
    var writeNumber = writeNumberCached;
    var toGenerate = true;
    function generate(packet, stream, opts) {
      debug("generate called");
      if (stream.cork) {
        stream.cork();
        nextTick(uncork, stream);
      }
      if (toGenerate) {
        toGenerate = false;
        generateCache();
      }
      debug("generate: packet.cmd: %s", packet.cmd);
      switch (packet.cmd) {
        case "connect":
          return connect(packet, stream, opts);
        case "connack":
          return connack(packet, stream, opts);
        case "publish":
          return publish(packet, stream, opts);
        case "puback":
        case "pubrec":
        case "pubrel":
        case "pubcomp":
          return confirmation(packet, stream, opts);
        case "subscribe":
          return subscribe(packet, stream, opts);
        case "suback":
          return suback(packet, stream, opts);
        case "unsubscribe":
          return unsubscribe(packet, stream, opts);
        case "unsuback":
          return unsuback(packet, stream, opts);
        case "pingreq":
        case "pingresp":
          return emptyPacket(packet, stream, opts);
        case "disconnect":
          return disconnect(packet, stream, opts);
        case "auth":
          return auth(packet, stream, opts);
        default:
          stream.destroy(new Error("Unknown command"));
          return false;
      }
    }
    Object.defineProperty(generate, "cacheNumbers", {
      get() {
        return writeNumber === writeNumberCached;
      },
      set(value) {
        if (value) {
          if (!numCache || Object.keys(numCache).length === 0)
            toGenerate = true;
          writeNumber = writeNumberCached;
        } else {
          toGenerate = false;
          writeNumber = writeNumberGenerated;
        }
      }
    });
    function uncork(stream) {
      stream.uncork();
    }
    function connect(packet, stream, opts) {
      const settings = packet || {};
      const protocolId = settings.protocolId || "MQTT";
      let protocolVersion = settings.protocolVersion || 4;
      const will = settings.will;
      let clean = settings.clean;
      const keepalive = settings.keepalive || 0;
      const clientId2 = settings.clientId || "";
      const username = settings.username;
      const password = settings.password;
      const properties = settings.properties;
      if (clean === void 0)
        clean = true;
      let length = 0;
      if (!protocolId || typeof protocolId !== "string" && !Buffer2.isBuffer(protocolId)) {
        stream.destroy(new Error("Invalid protocolId"));
        return false;
      } else
        length += protocolId.length + 2;
      if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
        stream.destroy(new Error("Invalid protocol version"));
        return false;
      } else
        length += 1;
      if ((typeof clientId2 === "string" || Buffer2.isBuffer(clientId2)) && (clientId2 || protocolVersion >= 4) && (clientId2 || clean)) {
        length += Buffer2.byteLength(clientId2) + 2;
      } else {
        if (protocolVersion < 4) {
          stream.destroy(new Error("clientId must be supplied before 3.1.1"));
          return false;
        }
        if (clean * 1 === 0) {
          stream.destroy(new Error("clientId must be given if cleanSession set to 0"));
          return false;
        }
      }
      if (typeof keepalive !== "number" || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {
        stream.destroy(new Error("Invalid keepalive"));
        return false;
      } else
        length += 2;
      length += 1;
      let propertiesData;
      let willProperties;
      if (protocolVersion === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (will) {
        if (typeof will !== "object") {
          stream.destroy(new Error("Invalid will"));
          return false;
        }
        if (!will.topic || typeof will.topic !== "string") {
          stream.destroy(new Error("Invalid will topic"));
          return false;
        } else {
          length += Buffer2.byteLength(will.topic) + 2;
        }
        length += 2;
        if (will.payload) {
          if (will.payload.length >= 0) {
            if (typeof will.payload === "string") {
              length += Buffer2.byteLength(will.payload);
            } else {
              length += will.payload.length;
            }
          } else {
            stream.destroy(new Error("Invalid will payload"));
            return false;
          }
        }
        willProperties = {};
        if (protocolVersion === 5) {
          willProperties = getProperties(stream, will.properties);
          if (!willProperties) {
            return false;
          }
          length += willProperties.length;
        }
      }
      let providedUsername = false;
      if (username != null) {
        if (isStringOrBuffer(username)) {
          providedUsername = true;
          length += Buffer2.byteLength(username) + 2;
        } else {
          stream.destroy(new Error("Invalid username"));
          return false;
        }
      }
      if (password != null) {
        if (!providedUsername) {
          stream.destroy(new Error("Username is required to use password"));
          return false;
        }
        if (isStringOrBuffer(password)) {
          length += byteLength(password) + 2;
        } else {
          stream.destroy(new Error("Invalid password"));
          return false;
        }
      }
      stream.write(protocol.CONNECT_HEADER);
      writeVarByteInt(stream, length);
      writeStringOrBuffer(stream, protocolId);
      if (settings.bridgeMode) {
        protocolVersion += 128;
      }
      stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3);
      let flags = 0;
      flags |= username != null ? protocol.USERNAME_MASK : 0;
      flags |= password != null ? protocol.PASSWORD_MASK : 0;
      flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;
      flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;
      flags |= will ? protocol.WILL_FLAG_MASK : 0;
      flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;
      stream.write(Buffer2.from([flags]));
      writeNumber(stream, keepalive);
      if (protocolVersion === 5) {
        propertiesData.write();
      }
      writeStringOrBuffer(stream, clientId2);
      if (will) {
        if (protocolVersion === 5) {
          willProperties.write();
        }
        writeString(stream, will.topic);
        writeStringOrBuffer(stream, will.payload);
      }
      if (username != null) {
        writeStringOrBuffer(stream, username);
      }
      if (password != null) {
        writeStringOrBuffer(stream, password);
      }
      return true;
    }
    function connack(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const rc = version === 5 ? settings.reasonCode : settings.returnCode;
      const properties = settings.properties;
      let length = 2;
      if (typeof rc !== "number") {
        stream.destroy(new Error("Invalid return code"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.CONNACK_HEADER);
      writeVarByteInt(stream, length);
      stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);
      stream.write(Buffer2.from([rc]));
      if (propertiesData != null) {
        propertiesData.write();
      }
      return true;
    }
    function publish(packet, stream, opts) {
      debug("publish: packet: %o", packet);
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const qos = settings.qos || 0;
      const retain = settings.retain ? protocol.RETAIN_MASK : 0;
      const topic = settings.topic;
      const payload = settings.payload || empty;
      const id = settings.messageId;
      const properties = settings.properties;
      let length = 0;
      if (typeof topic === "string")
        length += Buffer2.byteLength(topic) + 2;
      else if (Buffer2.isBuffer(topic))
        length += topic.length + 2;
      else {
        stream.destroy(new Error("Invalid topic"));
        return false;
      }
      if (!Buffer2.isBuffer(payload))
        length += Buffer2.byteLength(payload);
      else
        length += payload.length;
      if (qos && typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      } else if (qos)
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, byteLength(topic));
      stream.write(topic);
      if (qos > 0)
        writeNumber(stream, id);
      if (propertiesData != null) {
        propertiesData.write();
      }
      debug("publish: payload: %o", payload);
      return stream.write(payload);
    }
    function confirmation(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const type = settings.cmd || "puback";
      const id = settings.messageId;
      const dup = settings.dup && type === "pubrel" ? protocol.DUP_MASK : 0;
      let qos = 0;
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 3 : 2;
      if (type === "pubrel")
        qos = 1;
      if (typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        if (typeof properties === "object") {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      if (length === 3)
        length += reasonCode !== 0 ? 1 : -1;
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (version === 5 && length !== 2) {
        stream.write(Buffer2.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      } else {
        if (length === 4) {
          stream.write(Buffer2.from([0]));
        }
      }
      return true;
    }
    function subscribe(packet, stream, opts) {
      debug("subscribe: packet: ");
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const id = settings.messageId;
      const subs = settings.subscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (typeof subs === "object" && subs.length) {
        for (let i = 0; i < subs.length; i += 1) {
          const itopic = subs[i].topic;
          const iqos = subs[i].qos;
          if (typeof itopic !== "string") {
            stream.destroy(new Error("Invalid subscriptions - invalid topic"));
            return false;
          }
          if (typeof iqos !== "number") {
            stream.destroy(new Error("Invalid subscriptions - invalid qos"));
            return false;
          }
          if (version === 5) {
            const nl = subs[i].nl || false;
            if (typeof nl !== "boolean") {
              stream.destroy(new Error("Invalid subscriptions - invalid No Local"));
              return false;
            }
            const rap = subs[i].rap || false;
            if (typeof rap !== "boolean") {
              stream.destroy(new Error("Invalid subscriptions - invalid Retain as Published"));
              return false;
            }
            const rh = subs[i].rh || 0;
            if (typeof rh !== "number" || rh > 2) {
              stream.destroy(new Error("Invalid subscriptions - invalid Retain Handling"));
              return false;
            }
          }
          length += Buffer2.byteLength(itopic) + 2 + 1;
        }
      } else {
        stream.destroy(new Error("Invalid subscriptions"));
        return false;
      }
      debug("subscribe: writing to stream: %o", protocol.SUBSCRIBE_HEADER);
      stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (const sub of subs) {
        const jtopic = sub.topic;
        const jqos = sub.qos;
        const jnl = +sub.nl;
        const jrap = +sub.rap;
        const jrh = sub.rh;
        let joptions;
        writeString(stream, jtopic);
        joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];
        if (version === 5) {
          joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;
          joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;
          joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;
        }
        result = stream.write(Buffer2.from([joptions]));
      }
      return result;
    }
    function suback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const granted = settings.granted;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      if (typeof granted === "object" && granted.length) {
        for (let i = 0; i < granted.length; i += 1) {
          if (typeof granted[i] !== "number") {
            stream.destroy(new Error("Invalid qos vector"));
            return false;
          }
          length += 1;
        }
      } else {
        stream.destroy(new Error("Invalid qos vector"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.SUBACK_HEADER);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return stream.write(Buffer2.from(granted));
    }
    function unsubscribe(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const unsubs = settings.unsubscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      } else {
        length += 2;
      }
      if (typeof unsubs === "object" && unsubs.length) {
        for (let i = 0; i < unsubs.length; i += 1) {
          if (typeof unsubs[i] !== "string") {
            stream.destroy(new Error("Invalid unsubscriptions"));
            return false;
          }
          length += Buffer2.byteLength(unsubs[i]) + 2;
        }
      } else {
        stream.destroy(new Error("Invalid unsubscriptions"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (let j = 0; j < unsubs.length; j++) {
        result = writeString(stream, unsubs[j]);
      }
      return result;
    }
    function unsuback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const granted = settings.granted;
      const properties = settings.properties;
      const type = settings.cmd;
      const qos = 0;
      let length = 2;
      if (typeof id !== "number") {
        stream.destroy(new Error("Invalid messageId"));
        return false;
      }
      if (version === 5) {
        if (typeof granted === "object" && granted.length) {
          for (let i = 0; i < granted.length; i += 1) {
            if (typeof granted[i] !== "number") {
              stream.destroy(new Error("Invalid qos vector"));
              return false;
            }
            length += 1;
          }
        } else {
          stream.destroy(new Error("Invalid qos vector"));
          return false;
        }
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      if (version === 5) {
        stream.write(Buffer2.from(granted));
      }
      return true;
    }
    function emptyPacket(packet, stream, opts) {
      return stream.write(protocol.EMPTY[packet.cmd]);
    }
    function disconnect(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(Buffer2.from([protocol.codes.disconnect << 4]));
      writeVarByteInt(stream, length);
      if (version === 5) {
        stream.write(Buffer2.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    function auth(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      if (version !== 5)
        stream.destroy(new Error("Invalid mqtt version for auth packet"));
      const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
      if (!propertiesData) {
        return false;
      }
      length += propertiesData.length;
      stream.write(Buffer2.from([protocol.codes.auth << 4]));
      writeVarByteInt(stream, length);
      stream.write(Buffer2.from([reasonCode]));
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    var varByteIntCache = {};
    function writeVarByteInt(stream, num) {
      if (num > protocol.VARBYTEINT_MAX) {
        stream.destroy(new Error(`Invalid variable byte integer: ${num}`));
        return false;
      }
      let buffer = varByteIntCache[num];
      if (!buffer) {
        buffer = genBufVariableByteInt(num);
        if (num < 16384)
          varByteIntCache[num] = buffer;
      }
      debug("writeVarByteInt: writing to stream: %o", buffer);
      return stream.write(buffer);
    }
    function writeString(stream, string) {
      const strlen = Buffer2.byteLength(string);
      writeNumber(stream, strlen);
      debug("writeString: %s", string);
      return stream.write(string, "utf8");
    }
    function writeStringPair(stream, name, value) {
      writeString(stream, name);
      writeString(stream, value);
    }
    function writeNumberCached(stream, number) {
      debug("writeNumberCached: number: %d", number);
      debug("writeNumberCached: %o", numCache[number]);
      return stream.write(numCache[number]);
    }
    function writeNumberGenerated(stream, number) {
      const generatedNumber = generateNumber(number);
      debug("writeNumberGenerated: %o", generatedNumber);
      return stream.write(generatedNumber);
    }
    function write4ByteNumber(stream, number) {
      const generated4ByteBuffer = generate4ByteBuffer(number);
      debug("write4ByteNumber: %o", generated4ByteBuffer);
      return stream.write(generated4ByteBuffer);
    }
    function writeStringOrBuffer(stream, toWrite) {
      if (typeof toWrite === "string") {
        writeString(stream, toWrite);
      } else if (toWrite) {
        writeNumber(stream, toWrite.length);
        stream.write(toWrite);
      } else
        writeNumber(stream, 0);
    }
    function getProperties(stream, properties) {
      if (typeof properties !== "object" || properties.length != null) {
        return {
          length: 1,
          write() {
            writeProperties(stream, {}, 0);
          }
        };
      }
      let propertiesLength = 0;
      function getLengthProperty(name, value) {
        const type = protocol.propertiesTypes[name];
        let length = 0;
        switch (type) {
          case "byte": {
            if (typeof value !== "boolean") {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "int8": {
            if (typeof value !== "number" || value < 0 || value > 255) {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "binary": {
            if (value && value === null) {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + Buffer2.byteLength(value) + 2;
            break;
          }
          case "int16": {
            if (typeof value !== "number" || value < 0 || value > 65535) {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2;
            break;
          }
          case "int32": {
            if (typeof value !== "number" || value < 0 || value > 4294967295) {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 4;
            break;
          }
          case "var": {
            if (typeof value !== "number" || value < 0 || value > 268435455) {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + Buffer2.byteLength(genBufVariableByteInt(value));
            break;
          }
          case "string": {
            if (typeof value !== "string") {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2 + Buffer2.byteLength(value.toString());
            break;
          }
          case "pair": {
            if (typeof value !== "object") {
              stream.destroy(new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += Object.getOwnPropertyNames(value).reduce((result, name2) => {
              const currentValue = value[name2];
              if (Array.isArray(currentValue)) {
                result += currentValue.reduce((currentLength, value2) => {
                  currentLength += 1 + 2 + Buffer2.byteLength(name2.toString()) + 2 + Buffer2.byteLength(value2.toString());
                  return currentLength;
                }, 0);
              } else {
                result += 1 + 2 + Buffer2.byteLength(name2.toString()) + 2 + Buffer2.byteLength(value[name2].toString());
              }
              return result;
            }, 0);
            break;
          }
          default: {
            stream.destroy(new Error(`Invalid property ${name}: ${value}`));
            return false;
          }
        }
        return length;
      }
      if (properties) {
        for (const propName in properties) {
          let propLength = 0;
          let propValueLength = 0;
          const propValue = properties[propName];
          if (Array.isArray(propValue)) {
            for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
              propValueLength = getLengthProperty(propName, propValue[valueIndex]);
              if (!propValueLength) {
                return false;
              }
              propLength += propValueLength;
            }
          } else {
            propValueLength = getLengthProperty(propName, propValue);
            if (!propValueLength) {
              return false;
            }
            propLength = propValueLength;
          }
          if (!propLength)
            return false;
          propertiesLength += propLength;
        }
      }
      const propertiesLengthLength = Buffer2.byteLength(genBufVariableByteInt(propertiesLength));
      return {
        length: propertiesLengthLength + propertiesLength,
        write() {
          writeProperties(stream, properties, propertiesLength);
        }
      };
    }
    function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {
      const mayEmptyProps = ["reasonString", "userProperties"];
      const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;
      let propertiesData = getProperties(stream, properties);
      if (maximumPacketSize) {
        while (length + propertiesData.length > maximumPacketSize) {
          const currentMayEmptyProp = mayEmptyProps.shift();
          if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
            delete properties[currentMayEmptyProp];
            propertiesData = getProperties(stream, properties);
          } else {
            return false;
          }
        }
      }
      return propertiesData;
    }
    function writeProperty(stream, propName, value) {
      const type = protocol.propertiesTypes[propName];
      switch (type) {
        case "byte": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          stream.write(Buffer2.from([+value]));
          break;
        }
        case "int8": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          stream.write(Buffer2.from([value]));
          break;
        }
        case "binary": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          writeStringOrBuffer(stream, value);
          break;
        }
        case "int16": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          writeNumber(stream, value);
          break;
        }
        case "int32": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          write4ByteNumber(stream, value);
          break;
        }
        case "var": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          writeVarByteInt(stream, value);
          break;
        }
        case "string": {
          stream.write(Buffer2.from([protocol.properties[propName]]));
          writeString(stream, value);
          break;
        }
        case "pair": {
          Object.getOwnPropertyNames(value).forEach((name) => {
            const currentValue = value[name];
            if (Array.isArray(currentValue)) {
              currentValue.forEach((value2) => {
                stream.write(Buffer2.from([protocol.properties[propName]]));
                writeStringPair(stream, name.toString(), value2.toString());
              });
            } else {
              stream.write(Buffer2.from([protocol.properties[propName]]));
              writeStringPair(stream, name.toString(), currentValue.toString());
            }
          });
          break;
        }
        default: {
          stream.destroy(new Error(`Invalid property ${propName} value: ${value}`));
          return false;
        }
      }
    }
    function writeProperties(stream, properties, propertiesLength) {
      writeVarByteInt(stream, propertiesLength);
      for (const propName in properties) {
        if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
          const value = properties[propName];
          if (Array.isArray(value)) {
            for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
              writeProperty(stream, propName, value[valueIndex]);
            }
          } else {
            writeProperty(stream, propName, value);
          }
        }
      }
    }
    function byteLength(bufOrString) {
      if (!bufOrString)
        return 0;
      else if (bufOrString instanceof Buffer2)
        return bufOrString.length;
      else
        return Buffer2.byteLength(bufOrString);
    }
    function isStringOrBuffer(field) {
      return typeof field === "string" || field instanceof Buffer2;
    }
    module2.exports = generate;
  }
});

// node_modules/mqtt-packet/generate.js
var require_generate = __commonJS({
  "node_modules/mqtt-packet/generate.js"(exports, module2) {
    var writeToStream = require_writeToStream();
    var { EventEmitter } = require("events");
    var { Buffer: Buffer2 } = require("buffer");
    function generate(packet, opts) {
      const stream = new Accumulator();
      writeToStream(packet, stream, opts);
      return stream.concat();
    }
    var Accumulator = class extends EventEmitter {
      constructor() {
        super();
        this._array = new Array(20);
        this._i = 0;
      }
      write(chunk) {
        this._array[this._i++] = chunk;
        return true;
      }
      concat() {
        let length = 0;
        const lengths = new Array(this._array.length);
        const list = this._array;
        let pos = 0;
        let i;
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string")
            lengths[i] = list[i].length;
          else
            lengths[i] = Buffer2.byteLength(list[i]);
          length += lengths[i];
        }
        const result = Buffer2.allocUnsafe(length);
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string") {
            list[i].copy(result, pos);
            pos += lengths[i];
          } else {
            result.write(list[i], pos);
            pos += lengths[i];
          }
        }
        return result;
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
      }
    };
    module2.exports = generate;
  }
});

// node_modules/mqtt-packet/mqtt.js
var require_mqtt = __commonJS({
  "node_modules/mqtt-packet/mqtt.js"(exports) {
    exports.parser = require_parser().parser;
    exports.generate = require_generate();
    exports.writeToStream = require_writeToStream();
  }
});

// node_modules/mqtt/build/lib/default-message-id-provider.js
var require_default_message_id_provider = __commonJS({
  "node_modules/mqtt/build/lib/default-message-id-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultMessageIdProvider = class {
      constructor() {
        this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
      }
      allocate() {
        const id = this.nextId++;
        if (this.nextId === 65536) {
          this.nextId = 1;
        }
        return id;
      }
      getLastAllocated() {
        return this.nextId === 1 ? 65535 : this.nextId - 1;
      }
      register(messageId) {
        return true;
      }
      deallocate(messageId) {
      }
      clear() {
      }
    };
    exports.default = DefaultMessageIdProvider;
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports, module2) {
    "use strict";
    module2.exports = require_rfdc()();
  }
});

// node_modules/mqtt/build/lib/validations.js
var require_validations = __commonJS({
  "node_modules/mqtt/build/lib/validations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTopics = exports.validateTopic = void 0;
    function validateTopic(topic) {
      const parts = topic.split("/");
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] === "+") {
          continue;
        }
        if (parts[i] === "#") {
          return i === parts.length - 1;
        }
        if (parts[i].indexOf("+") !== -1 || parts[i].indexOf("#") !== -1) {
          return false;
        }
      }
      return true;
    }
    exports.validateTopic = validateTopic;
    function validateTopics(topics) {
      if (topics.length === 0) {
        return "empty_topic_list";
      }
      for (let i = 0; i < topics.length; i++) {
        if (!validateTopic(topics[i])) {
          return topics[i];
        }
      }
      return null;
    }
    exports.validateTopics = validateTopics;
  }
});

// node_modules/mqtt/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/mqtt/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/mqtt/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/mqtt/node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/mqtt/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/mqtt/node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/mqtt/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/mqtt/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/mqtt/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/mqtt/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/mqtt/build/lib/store.js
var require_store = __commonJS({
  "node_modules/mqtt/build/lib/store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var readable_stream_1 = require_ours();
    var streamsOpts = { objectMode: true };
    var defaultStoreOptions = {
      clean: true
    };
    var Store = class {
      constructor(options) {
        this.options = options || {};
        this.options = Object.assign(Object.assign({}, defaultStoreOptions), options);
        this._inflights = /* @__PURE__ */ new Map();
      }
      put(packet, cb) {
        this._inflights.set(packet.messageId, packet);
        if (cb) {
          cb();
        }
        return this;
      }
      createStream() {
        const stream = new readable_stream_1.Readable(streamsOpts);
        const values = [];
        let destroyed = false;
        let i = 0;
        this._inflights.forEach((value, key) => {
          values.push(value);
        });
        stream._read = () => {
          if (!destroyed && i < values.length) {
            stream.push(values[i++]);
          } else {
            stream.push(null);
          }
        };
        stream.destroy = (err) => {
          if (destroyed) {
            return;
          }
          destroyed = true;
          setTimeout(() => {
            stream.emit("close");
          }, 0);
          return stream;
        };
        return stream;
      }
      del(packet, cb) {
        const toDelete = this._inflights.get(packet.messageId);
        if (toDelete) {
          this._inflights.delete(packet.messageId);
          cb(null, toDelete);
        } else if (cb) {
          cb(new Error("missing packet"));
        }
        return this;
      }
      get(packet, cb) {
        const storedPacket = this._inflights.get(packet.messageId);
        if (storedPacket) {
          cb(null, storedPacket);
        } else if (cb) {
          cb(new Error("missing packet"));
        }
        return this;
      }
      close(cb) {
        if (this.options.clean) {
          this._inflights = null;
        }
        if (cb) {
          cb();
        }
      }
    };
    exports.default = Store;
  }
});

// node_modules/mqtt/build/lib/handlers/publish.js
var require_publish = __commonJS({
  "node_modules/mqtt/build/lib/handlers/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
    var handlePublish = (client, packet, done) => {
      client.log("handlePublish: packet %o", packet);
      done = typeof done !== "undefined" ? done : client.noop;
      let topic = packet.topic.toString();
      const message = packet.payload;
      const { qos } = packet;
      const { messageId } = packet;
      const { options } = client;
      if (client.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
          alias = packet.properties.topicAlias;
        }
        if (typeof alias !== "undefined") {
          if (topic.length === 0) {
            if (alias > 0 && alias <= 65535) {
              const gotTopic = client["topicAliasRecv"].getTopicByAlias(alias);
              if (gotTopic) {
                topic = gotTopic;
                client.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
              } else {
                client.log("handlePublish :: unregistered topic alias. alias: %d", alias);
                client.emit("error", new Error("Received unregistered Topic Alias"));
                return;
              }
            } else {
              client.log("handlePublish :: topic alias out of range. alias: %d", alias);
              client.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          } else if (client["topicAliasRecv"].put(topic, alias)) {
            client.log("handlePublish :: registered topic: %s - alias: %d", topic, alias);
          } else {
            client.log("handlePublish :: topic alias out of range. alias: %d", alias);
            client.emit("error", new Error("Received Topic Alias is out of range"));
            return;
          }
        }
      }
      client.log("handlePublish: qos %d", qos);
      switch (qos) {
        case 2: {
          options.customHandleAcks(topic, message, packet, (error, code) => {
            if (typeof error === "number") {
              code = error;
              error = null;
            }
            if (error) {
              return client.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return client.emit("error", new Error("Wrong reason code for pubrec"));
            }
            if (code) {
              client["_sendPacket"]({ cmd: "pubrec", messageId, reasonCode: code }, done);
            } else {
              client.incomingStore.put(packet, () => {
                client["_sendPacket"]({ cmd: "pubrec", messageId }, done);
              });
            }
          });
          break;
        }
        case 1: {
          options.customHandleAcks(topic, message, packet, (error, code) => {
            if (typeof error === "number") {
              code = error;
              error = null;
            }
            if (error) {
              return client.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return client.emit("error", new Error("Wrong reason code for puback"));
            }
            if (!code) {
              client.emit("message", topic, message, packet);
            }
            client.handleMessage(packet, (err) => {
              if (err) {
                return done && done(err);
              }
              client["_sendPacket"]({ cmd: "puback", messageId, reasonCode: code }, done);
            });
          });
          break;
        }
        case 0:
          client.emit("message", topic, message, packet);
          client.handleMessage(packet, done);
          break;
        default:
          client.log("handlePublish: unknown QoS. Doing nothing.");
          break;
      }
    };
    exports.default = handlePublish;
  }
});

// node_modules/mqtt/package.json
var require_package = __commonJS({
  "node_modules/mqtt/package.json"(exports, module2) {
    module2.exports = {
      name: "mqtt",
      description: "A library for the MQTT protocol",
      version: "5.10.1",
      contributors: [
        "Adam Rudd <adamvrr@gmail.com>",
        "Matteo Collina <matteo.collina@gmail.com> (https://github.com/mcollina)",
        "Siarhei Buntsevich <scarry0506@gmail.com> (https://github.com/scarry1992)",
        "Yoseph Maguire <yomaguir@microsoft.com> (https://github.com/YoDaMa)",
        "Daniel Lando <daniel.sorridi@gmail.com> (https://github.com/robertsLando)"
      ],
      keywords: [
        "mqtt",
        "publish/subscribe",
        "publish",
        "subscribe"
      ],
      license: "MIT",
      repository: {
        type: "git",
        url: "git://github.com/mqttjs/MQTT.js.git"
      },
      main: "./build/index.js",
      module: "./dist/mqtt.esm.js",
      bin: {
        mqtt_pub: "./build/bin/pub.js",
        mqtt_sub: "./build/bin/sub.js",
        mqtt: "./build/bin/mqtt.js"
      },
      files: [
        "dist/",
        "CONTRIBUTING.md",
        "LICENSE.md",
        "help/",
        "build/",
        "src/"
      ],
      exports: {
        ".": {
          browser: {
            import: "./dist/mqtt.esm.js",
            default: "./dist/mqtt.min.js"
          },
          default: "./build/index.js"
        },
        "./package.json": "./package.json",
        "./*.map": "./build/*.js.map",
        "./dist/*": "./dist/*.js",
        "./*": "./build/*.js"
      },
      types: "build/index.d.ts",
      typesVersions: {
        "*": {
          "*": [
            "./build/index.d.ts"
          ]
        }
      },
      scripts: {
        lint: "eslint --ext .ts .",
        "lint-fix": "eslint --fix --ext .ts .",
        "build:ts": "rimraf build/ && tsc -p tsconfig.build.json",
        "build:browser": "node esbuild.js",
        build: "npm run build:ts && npm run build:browser",
        prepare: "npm run build",
        "unit-test:node": "node_modules/.bin/nyc node -r esbuild-register test/runTests.ts",
        "unit-test:browser": "wtr",
        "test:node": "npm run unit-test:node && codecov",
        "test:browser": "npm run build && npm run unit-test:browser",
        test: "npm run test:node",
        changelog: "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
        "changelog-init": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
        release: "read -p 'GITHUB_TOKEN: ' GITHUB_TOKEN && export GITHUB_TOKEN=$GITHUB_TOKEN && release-it"
      },
      "release-it": {
        github: {
          release: true
        },
        git: {
          tagName: "v${version}",
          commitMessage: "chore(release): ${version}"
        },
        hooks: {
          "before:init": [
            "npm run test"
          ]
        },
        npm: {
          publish: true
        },
        plugins: {
          "@release-it/conventional-changelog": {
            preset: "angular",
            infile: "CHANGELOG.md"
          }
        }
      },
      "pre-commit": [
        "lint"
      ],
      engines: {
        node: ">=16.0.0"
      },
      browser: {
        "./mqtt.js": "./dist/mqtt.js",
        fs: false,
        tls: false,
        net: false
      },
      dependencies: {
        "@types/readable-stream": "^4.0.5",
        "@types/ws": "^8.5.9",
        commist: "^3.2.0",
        "concat-stream": "^2.0.0",
        debug: "^4.3.4",
        "help-me": "^5.0.0",
        "lru-cache": "^10.0.1",
        minimist: "^1.2.8",
        "mqtt-packet": "^9.0.0",
        "number-allocator": "^1.0.14",
        "readable-stream": "^4.4.2",
        reinterval: "^1.1.0",
        rfdc: "^1.3.0",
        split2: "^4.2.0",
        "worker-timers": "^7.1.4",
        ws: "^8.17.1"
      },
      devDependencies: {
        "@esm-bundle/chai": "^4.3.4-fix.0",
        "@release-it/conventional-changelog": "^7.0.2",
        "@types/chai": "^4.3.10",
        "@types/node": "^20.9.0",
        "@types/sinon": "^17.0.1",
        "@types/tape": "^5.6.4",
        "@typescript-eslint/eslint-plugin": "^6.10.0",
        "@typescript-eslint/parser": "^6.10.0",
        "@web/test-runner": "^0.18.0",
        "@web/test-runner-playwright": "^0.11.0",
        "aedes-cli": "^0.8.0",
        chai: "^4.3.10",
        chokidar: "^3.5.3",
        codecov: "^3.8.2",
        "conventional-changelog-cli": "^4.1.0",
        "end-of-stream": "^1.4.4",
        esbuild: "^0.19.5",
        "esbuild-plugin-polyfill-node": "^0.3.0",
        "esbuild-register": "^3.5.0",
        eslint: "^8.53.0",
        "eslint-config-airbnb-base": "^15.0.0",
        "eslint-config-airbnb-typescript": "^17.1.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-import": "^2.29.0",
        "eslint-plugin-prettier": "^5.0.1",
        global: "^4.4.0",
        "leaked-handles": "^5.2.0",
        mkdirp: "^3.0.1",
        "mqtt-connection": "^4.1.0",
        "mqtt-level-store": "^3.1.0",
        nyc: "^15.1.0",
        "pre-commit": "^1.2.2",
        prettier: "^3.0.3",
        "release-it": "^16.2.1",
        rimraf: "^5.0.5",
        should: "^13.2.3",
        sinon: "^17.0.1",
        snazzy: "^9.0.0",
        tape: "^5.7.2",
        "ts-node": "^10.9.1",
        typescript: "^5.2.2"
      }
    };
  }
});

// node_modules/mqtt/build/lib/shared.js
var require_shared = __commonJS({
  "node_modules/mqtt/build/lib/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MQTTJS_VERSION = exports.nextTick = exports.applyMixin = exports.ErrorWithReasonCode = void 0;
    var ErrorWithReasonCode = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ErrorWithReasonCode.prototype);
        Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
      }
    };
    exports.ErrorWithReasonCode = ErrorWithReasonCode;
    function applyMixin(target, mixin, includeConstructor = false) {
      var _a;
      const inheritanceChain = [mixin];
      while (true) {
        const current = inheritanceChain[0];
        const base = Object.getPrototypeOf(current);
        if (base === null || base === void 0 ? void 0 : base.prototype) {
          inheritanceChain.unshift(base);
        } else {
          break;
        }
      }
      for (const ctor of inheritanceChain) {
        for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
          if (includeConstructor || prop !== "constructor") {
            Object.defineProperty(target.prototype, prop, (_a = Object.getOwnPropertyDescriptor(ctor.prototype, prop)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ Object.create(null));
          }
        }
      }
    }
    exports.applyMixin = applyMixin;
    exports.nextTick = typeof (process === null || process === void 0 ? void 0 : process.nextTick) === "function" ? process.nextTick : (callback) => {
      setTimeout(callback, 0);
    };
    exports.MQTTJS_VERSION = require_package().version;
  }
});

// node_modules/mqtt/build/lib/handlers/ack.js
var require_ack = __commonJS({
  "node_modules/mqtt/build/lib/handlers/ack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReasonCodes = void 0;
    var shared_1 = require_shared();
    exports.ReasonCodes = {
      0: "",
      1: "Unacceptable protocol version",
      2: "Identifier rejected",
      3: "Server unavailable",
      4: "Bad username or password",
      5: "Not authorized",
      16: "No matching subscribers",
      17: "No subscription existed",
      128: "Unspecified error",
      129: "Malformed Packet",
      130: "Protocol Error",
      131: "Implementation specific error",
      132: "Unsupported Protocol Version",
      133: "Client Identifier not valid",
      134: "Bad User Name or Password",
      135: "Not authorized",
      136: "Server unavailable",
      137: "Server busy",
      138: "Banned",
      139: "Server shutting down",
      140: "Bad authentication method",
      141: "Keep Alive timeout",
      142: "Session taken over",
      143: "Topic Filter invalid",
      144: "Topic Name invalid",
      145: "Packet identifier in use",
      146: "Packet Identifier not found",
      147: "Receive Maximum exceeded",
      148: "Topic Alias invalid",
      149: "Packet too large",
      150: "Message rate too high",
      151: "Quota exceeded",
      152: "Administrative action",
      153: "Payload format invalid",
      154: "Retain not supported",
      155: "QoS not supported",
      156: "Use another server",
      157: "Server moved",
      158: "Shared Subscriptions not supported",
      159: "Connection rate exceeded",
      160: "Maximum connect time",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    var handleAck = (client, packet) => {
      const { messageId } = packet;
      const type = packet.cmd;
      let response = null;
      const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null;
      let err = null;
      if (!cb) {
        client.log("_handleAck :: Server sent an ack in error. Ignoring.");
        return;
      }
      client.log("_handleAck :: packet type", type);
      switch (type) {
        case "pubcomp":
        case "puback": {
          const pubackRC = packet.reasonCode;
          if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
            err = new shared_1.ErrorWithReasonCode(`Publish error: ${exports.ReasonCodes[pubackRC]}`, pubackRC);
            client["_removeOutgoingAndStoreMessage"](messageId, () => {
              cb(err, packet);
            });
          } else {
            client["_removeOutgoingAndStoreMessage"](messageId, cb);
          }
          break;
        }
        case "pubrec": {
          response = {
            cmd: "pubrel",
            qos: 2,
            messageId
          };
          const pubrecRC = packet.reasonCode;
          if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
            err = new shared_1.ErrorWithReasonCode(`Publish error: ${exports.ReasonCodes[pubrecRC]}`, pubrecRC);
            client["_removeOutgoingAndStoreMessage"](messageId, () => {
              cb(err, packet);
            });
          } else {
            client["_sendPacket"](response);
          }
          break;
        }
        case "suback": {
          delete client.outgoing[messageId];
          client.messageIdProvider.deallocate(messageId);
          const granted = packet.granted;
          for (let grantedI = 0; grantedI < granted.length; grantedI++) {
            const subackRC = granted[grantedI];
            if ((subackRC & 128) !== 0) {
              err = new Error(`Subscribe error: ${exports.ReasonCodes[subackRC]}`);
              err.code = subackRC;
              const topics = client.messageIdToTopic[messageId];
              if (topics) {
                topics.forEach((topic) => {
                  delete client["_resubscribeTopics"][topic];
                });
              }
            }
          }
          delete client.messageIdToTopic[messageId];
          client["_invokeStoreProcessingQueue"]();
          cb(err, packet);
          break;
        }
        case "unsuback": {
          delete client.outgoing[messageId];
          client.messageIdProvider.deallocate(messageId);
          client["_invokeStoreProcessingQueue"]();
          cb(null, packet);
          break;
        }
        default:
          client.emit("error", new Error("unrecognized packet type"));
      }
      if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
        client.emit("outgoingEmpty");
      }
    };
    exports.default = handleAck;
  }
});

// node_modules/mqtt/build/lib/handlers/auth.js
var require_auth = __commonJS({
  "node_modules/mqtt/build/lib/handlers/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared_1 = require_shared();
    var ack_1 = require_ack();
    var handleAuth = (client, packet) => {
      const { options } = client;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      if (version !== 5) {
        const err = new shared_1.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version}`, rc);
        client.emit("error", err);
        return;
      }
      client.handleAuth(packet, (err, packet2) => {
        if (err) {
          client.emit("error", err);
          return;
        }
        if (rc === 24) {
          client.reconnecting = false;
          client["_sendPacket"](packet2);
        } else {
          const error = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
          client.emit("error", error);
        }
      });
    };
    exports.default = handleAuth;
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class {
      constructor(max, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s = new _Stack(max, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var Stack = _Stack;
    _constructing = new WeakMap();
    __privateAdd(Stack, _constructing, false);
    var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _a, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn, _delete, delete_fn, _clear, clear_fn;
    var _LRUCache = class {
      constructor(options) {
        __privateAdd(this, _initializeTTLTracking);
        __privateAdd(this, _initializeSizeTracking);
        __privateAdd(this, _indexes);
        __privateAdd(this, _rindexes);
        __privateAdd(this, _isValidIndex);
        __privateAdd(this, _evict);
        __privateAdd(this, _backgroundFetch);
        __privateAdd(this, _isBackgroundFetch);
        __privateAdd(this, _connect);
        __privateAdd(this, _moveToTail);
        __privateAdd(this, _delete);
        __privateAdd(this, _clear);
        __privateAdd(this, _max, void 0);
        __privateAdd(this, _maxSize, void 0);
        __privateAdd(this, _dispose, void 0);
        __privateAdd(this, _disposeAfter, void 0);
        __privateAdd(this, _fetchMethod, void 0);
        __privateAdd(this, _memoMethod, void 0);
        __publicField(this, "ttl");
        __publicField(this, "ttlResolution");
        __publicField(this, "ttlAutopurge");
        __publicField(this, "updateAgeOnGet");
        __publicField(this, "updateAgeOnHas");
        __publicField(this, "allowStale");
        __publicField(this, "noDisposeOnSet");
        __publicField(this, "noUpdateTTL");
        __publicField(this, "maxEntrySize");
        __publicField(this, "sizeCalculation");
        __publicField(this, "noDeleteOnFetchRejection");
        __publicField(this, "noDeleteOnStaleGet");
        __publicField(this, "allowStaleOnFetchAbort");
        __publicField(this, "allowStaleOnFetchRejection");
        __publicField(this, "ignoreFetchAbort");
        __privateAdd(this, _size, void 0);
        __privateAdd(this, _calculatedSize, void 0);
        __privateAdd(this, _keyMap, void 0);
        __privateAdd(this, _keyList, void 0);
        __privateAdd(this, _valList, void 0);
        __privateAdd(this, _next, void 0);
        __privateAdd(this, _prev, void 0);
        __privateAdd(this, _head, void 0);
        __privateAdd(this, _tail, void 0);
        __privateAdd(this, _free, void 0);
        __privateAdd(this, _disposed, void 0);
        __privateAdd(this, _sizes, void 0);
        __privateAdd(this, _starts, void 0);
        __privateAdd(this, _ttls, void 0);
        __privateAdd(this, _hasDispose, void 0);
        __privateAdd(this, _hasFetchMethod, void 0);
        __privateAdd(this, _hasDisposeAfter, void 0);
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        __publicField(this, _a, "LRUCache");
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        __privateSet(this, _max, max);
        __privateSet(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        __privateSet(this, _memoMethod, memoMethod);
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max).fill(void 0));
        __privateSet(this, _valList, new Array(max).fill(void 0));
        __privateSet(this, _next, new UintArray(max));
        __privateSet(this, _prev, new UintArray(max));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max));
        __privateSet(this, _size, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      static unsafeExposeInternals(c) {
        return {
          starts: __privateGet(c, _starts),
          ttls: __privateGet(c, _ttls),
          sizes: __privateGet(c, _sizes),
          keyMap: __privateGet(c, _keyMap),
          keyList: __privateGet(c, _keyList),
          valList: __privateGet(c, _valList),
          next: __privateGet(c, _next),
          prev: __privateGet(c, _prev),
          get head() {
            return __privateGet(c, _head);
          },
          get tail() {
            return __privateGet(c, _tail);
          },
          free: __privateGet(c, _free),
          isBackgroundFetch: (p) => {
            var _a2;
            return __privateMethod(_a2 = c, _isBackgroundFetch, isBackgroundFetch_fn).call(_a2, p);
          },
          backgroundFetch: (k, index, options, context) => {
            var _a2;
            return __privateMethod(_a2 = c, _backgroundFetch, backgroundFetch_fn).call(_a2, k, index, options, context);
          },
          moveToTail: (index) => {
            var _a2;
            return __privateMethod(_a2 = c, _moveToTail, moveToTail_fn).call(_a2, index);
          },
          indexes: (options) => {
            var _a2;
            return __privateMethod(_a2 = c, _indexes, indexes_fn).call(_a2, options);
          },
          rindexes: (options) => {
            var _a2;
            return __privateMethod(_a2 = c, _rindexes, rindexes_fn).call(_a2, options);
          },
          isStale: (index) => {
            var _a2;
            return __privateGet(_a2 = c, _isStale).call(_a2, index);
          }
        };
      }
      get max() {
        return __privateGet(this, _max);
      }
      get maxSize() {
        return __privateGet(this, _maxSize);
      }
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      get size() {
        return __privateGet(this, _size);
      }
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      get memoMethod() {
        return __privateGet(this, _memoMethod);
      }
      get dispose() {
        return __privateGet(this, _dispose);
      }
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      getRemainingTTL(key) {
        return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
      }
      *entries() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      *rentries() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      *keys() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      *rkeys() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      *values() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      *rvalues() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, __privateGet(this, _keyList)[i], this)) {
            return this.get(__privateGet(this, _keyList)[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      purgeStale() {
        let deleted = false;
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i)) {
            __privateMethod(this, _delete, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      info(key) {
        const i = __privateGet(this, _keyMap).get(key);
        if (i === void 0)
          return void 0;
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          const ttl = __privateGet(this, _ttls)[i];
          const start = __privateGet(this, _starts)[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i];
        }
        return entry;
      }
      dump() {
        const arr = [];
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
          const key = __privateGet(this, _keyList)[i];
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i];
            const age = perf.now() - __privateGet(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      set(k, v, setOptions = {}) {
        var _a2, _b, _c;
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          __privateMethod(this, _delete, delete_fn).call(this, k, "set");
          return this;
        }
        let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
          __privateGet(this, _keyList)[index] = k;
          __privateGet(this, _valList)[index] = v;
          __privateGet(this, _keyMap).set(k, index);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index;
          __privateGet(this, _prev)[index] = __privateGet(this, _tail);
          __privateSet(this, _tail, index);
          __privateWrapper(this, _size)._++;
          __privateGet(this, _addItemSize).call(this, index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
          const oldVal = __privateGet(this, _valList)[index];
          if (v !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (__privateGet(this, _hasDispose)) {
                  (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, s, k, "set");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  __privateGet(this, _disposed)?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_b = __privateGet(this, _dispose)) == null ? void 0 : _b.call(this, oldVal, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([oldVal, k, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index);
            __privateGet(this, _addItemSize).call(this, index, size, status);
            __privateGet(this, _valList)[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
          }
        }
        return this;
      }
      pop() {
        var _a2;
        try {
          while (__privateGet(this, _size)) {
            const val = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _evict, evict_fn).call(this, true);
            if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt?.shift()) {
              (_a2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a2.call(this, ...task);
            }
          }
        }
      }
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
          return;
        }
        const v = __privateGet(this, _valList)[index];
        return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index, options, context);
          return p.__returned = p;
        } else {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = __privateGet(this, _isStale).call(this, index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index);
            return v;
          }
          const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = __privateGet(this, _memoMethod);
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const value = __privateGet(this, _valList)[index];
          const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
          if (__privateGet(this, _isStale).call(this, index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                __privateMethod(this, _delete, delete_fn).call(this, k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      delete(k) {
        return __privateMethod(this, _delete, delete_fn).call(this, k, "delete");
      }
      clear() {
        return __privateMethod(this, _clear, clear_fn).call(this, "delete");
      }
    };
    var LRUCache = _LRUCache;
    _a = Symbol.toStringTag;
    _max = new WeakMap();
    _maxSize = new WeakMap();
    _dispose = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _memoMethod = new WeakMap();
    _size = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _initializeTTLTracking = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index)) {
              __privateMethod(this, _delete, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = __privateGet(this, _keyMap).get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      __privateSet(this, _isStale, (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    _initializeSizeTracking = new WeakSet();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
      });
      __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      __privateSet(this, _addItemSize, (index, size, status) => {
        sizes[index] = size;
        if (__privateGet(this, _maxSize)) {
          const maxSize = __privateGet(this, _maxSize) - sizes[index];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _evict, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    _indexes = new WeakSet();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _head)) {
            break;
          } else {
            i = __privateGet(this, _prev)[i];
          }
        }
      }
    };
    _rindexes = new WeakSet();
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _tail)) {
            break;
          } else {
            i = __privateGet(this, _next)[i];
          }
        }
      }
    };
    _isValidIndex = new WeakSet();
    isValidIndex_fn = function(index) {
      return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
    };
    _evict = new WeakSet();
    evict_fn = function(free) {
      var _a2;
      const head = __privateGet(this, _head);
      const k = __privateGet(this, _keyList)[head];
      const v = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v, k, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k);
      __privateWrapper(this, _size)._--;
      return head;
    };
    _backgroundFetch = new WeakSet();
    backgroundFetch_fn = function(k, index, options, context) {
      const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
            } else {
              __privateMethod(this, _delete, delete_fn).call(this, k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            __privateMethod(this, _delete, delete_fn).call(this, k, "fetch");
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a2;
        const fmp = (_a2 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a2.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = __privateGet(this, _keyMap).get(k);
      } else {
        __privateGet(this, _valList)[index] = bf;
      }
      return bf;
    };
    _isBackgroundFetch = new WeakSet();
    isBackgroundFetch_fn = function(p) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    _connect = new WeakSet();
    connect_fn = function(p, n) {
      __privateGet(this, _prev)[n] = p;
      __privateGet(this, _next)[p] = n;
    };
    _moveToTail = new WeakSet();
    moveToTail_fn = function(index) {
      if (index !== __privateGet(this, _tail)) {
        if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
        }
        __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index);
        __privateSet(this, _tail, index);
      }
    };
    _delete = new WeakSet();
    delete_fn = function(k, reason) {
      var _a2, _b;
      let deleted = false;
      if (__privateGet(this, _size) !== 0) {
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          deleted = true;
          if (__privateGet(this, _size) === 1) {
            __privateMethod(this, _clear, clear_fn).call(this, reason);
          } else {
            __privateGet(this, _removeItemSize).call(this, index);
            const v = __privateGet(this, _valList)[index];
            if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
              if (__privateGet(this, _hasDispose)) {
                (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([v, k, reason]);
              }
            }
            __privateGet(this, _keyMap).delete(k);
            __privateGet(this, _keyList)[index] = void 0;
            __privateGet(this, _valList)[index] = void 0;
            if (index === __privateGet(this, _tail)) {
              __privateSet(this, _tail, __privateGet(this, _prev)[index]);
            } else if (index === __privateGet(this, _head)) {
              __privateSet(this, _head, __privateGet(this, _next)[index]);
            } else {
              const pi = __privateGet(this, _prev)[index];
              __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
              const ni = __privateGet(this, _next)[index];
              __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
            }
            __privateWrapper(this, _size)._--;
            __privateGet(this, _free).push(index);
          }
        }
      }
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
        }
      }
      return deleted;
    };
    _clear = new WeakSet();
    clear_fn = function(reason) {
      var _a2, _b;
      for (const index of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = __privateGet(this, _keyList)[index];
          if (__privateGet(this, _hasDispose)) {
            (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            __privateGet(this, _disposed)?.push([v, k, reason]);
          }
        }
      }
      __privateGet(this, _keyMap).clear();
      __privateGet(this, _valList).fill(void 0);
      __privateGet(this, _keyList).fill(void 0);
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        __privateGet(this, _ttls).fill(0);
        __privateGet(this, _starts).fill(0);
      }
      if (__privateGet(this, _sizes)) {
        __privateGet(this, _sizes).fill(0);
      }
      __privateSet(this, _head, 0);
      __privateSet(this, _tail, 0);
      __privateGet(this, _free).length = 0;
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _size, 0);
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/js-sdsl/dist/cjs/container/ContainerBase/index.js
var require_ContainerBase = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/ContainerBase/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.ContainerIterator = exports.Container = exports.Base = void 0;
    var ContainerIterator = class {
      constructor(t = 0) {
        this.iteratorType = t;
      }
      equals(t) {
        return this.o === t.o;
      }
    };
    exports.ContainerIterator = ContainerIterator;
    var Base = class {
      constructor() {
        this.i = 0;
      }
      get length() {
        return this.i;
      }
      size() {
        return this.i;
      }
      empty() {
        return this.i === 0;
      }
    };
    exports.Base = Base;
    var Container = class extends Base {
    };
    exports.Container = Container;
  }
});

// node_modules/js-sdsl/dist/cjs/container/OtherContainer/Stack.js
var require_Stack = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/OtherContainer/Stack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _ContainerBase = require_ContainerBase();
    var Stack = class extends _ContainerBase.Base {
      constructor(t = []) {
        super();
        this.S = [];
        const s = this;
        t.forEach(function(t2) {
          s.push(t2);
        });
      }
      clear() {
        this.i = 0;
        this.S = [];
      }
      push(t) {
        this.S.push(t);
        this.i += 1;
        return this.i;
      }
      pop() {
        if (this.i === 0)
          return;
        this.i -= 1;
        return this.S.pop();
      }
      top() {
        return this.S[this.i - 1];
      }
    };
    var _default = Stack;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/OtherContainer/Queue.js
var require_Queue = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/OtherContainer/Queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _ContainerBase = require_ContainerBase();
    var Queue = class extends _ContainerBase.Base {
      constructor(t = []) {
        super();
        this.j = 0;
        this.q = [];
        const s = this;
        t.forEach(function(t2) {
          s.push(t2);
        });
      }
      clear() {
        this.q = [];
        this.i = this.j = 0;
      }
      push(t) {
        const s = this.q.length;
        if (this.j / s > 0.5 && this.j + this.i >= s && s > 4096) {
          const s2 = this.i;
          for (let t2 = 0; t2 < s2; ++t2) {
            this.q[t2] = this.q[this.j + t2];
          }
          this.j = 0;
          this.q[this.i] = t;
        } else
          this.q[this.j + this.i] = t;
        return ++this.i;
      }
      pop() {
        if (this.i === 0)
          return;
        const t = this.q[this.j++];
        this.i -= 1;
        return t;
      }
      front() {
        if (this.i === 0)
          return;
        return this.q[this.j];
      }
    };
    var _default = Queue;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/OtherContainer/PriorityQueue.js
var require_PriorityQueue = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/OtherContainer/PriorityQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _ContainerBase = require_ContainerBase();
    var PriorityQueue = class extends _ContainerBase.Base {
      constructor(t = [], s = function(t2, s2) {
        if (t2 > s2)
          return -1;
        if (t2 < s2)
          return 1;
        return 0;
      }, i = true) {
        super();
        this.v = s;
        if (Array.isArray(t)) {
          this.C = i ? [...t] : t;
        } else {
          this.C = [];
          const s2 = this;
          t.forEach(function(t2) {
            s2.C.push(t2);
          });
        }
        this.i = this.C.length;
        const e = this.i >> 1;
        for (let t2 = this.i - 1 >> 1; t2 >= 0; --t2) {
          this.k(t2, e);
        }
      }
      m(t) {
        const s = this.C[t];
        while (t > 0) {
          const i = t - 1 >> 1;
          const e = this.C[i];
          if (this.v(e, s) <= 0)
            break;
          this.C[t] = e;
          t = i;
        }
        this.C[t] = s;
      }
      k(t, s) {
        const i = this.C[t];
        while (t < s) {
          let s2 = t << 1 | 1;
          const e = s2 + 1;
          let h = this.C[s2];
          if (e < this.i && this.v(h, this.C[e]) > 0) {
            s2 = e;
            h = this.C[e];
          }
          if (this.v(h, i) >= 0)
            break;
          this.C[t] = h;
          t = s2;
        }
        this.C[t] = i;
      }
      clear() {
        this.i = 0;
        this.C.length = 0;
      }
      push(t) {
        this.C.push(t);
        this.m(this.i);
        this.i += 1;
      }
      pop() {
        if (this.i === 0)
          return;
        const t = this.C[0];
        const s = this.C.pop();
        this.i -= 1;
        if (this.i) {
          this.C[0] = s;
          this.k(0, this.i >> 1);
        }
        return t;
      }
      top() {
        return this.C[0];
      }
      find(t) {
        return this.C.indexOf(t) >= 0;
      }
      remove(t) {
        const s = this.C.indexOf(t);
        if (s < 0)
          return false;
        if (s === 0) {
          this.pop();
        } else if (s === this.i - 1) {
          this.C.pop();
          this.i -= 1;
        } else {
          this.C.splice(s, 1, this.C.pop());
          this.i -= 1;
          this.m(s);
          this.k(s, this.i >> 1);
        }
        return true;
      }
      updateItem(t) {
        const s = this.C.indexOf(t);
        if (s < 0)
          return false;
        this.m(s);
        this.k(s, this.i >> 1);
        return true;
      }
      toArray() {
        return [...this.C];
      }
    };
    var _default = PriorityQueue;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/index.js
var require_Base = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _ContainerBase = require_ContainerBase();
    var SequentialContainer = class extends _ContainerBase.Container {
    };
    var _default = SequentialContainer;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/utils/throwError.js
var require_throwError = __commonJS({
  "node_modules/js-sdsl/dist/cjs/utils/throwError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.throwIteratorAccessError = throwIteratorAccessError;
    function throwIteratorAccessError() {
      throw new RangeError("Iterator access denied!");
    }
  }
});

// node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/RandomIterator.js
var require_RandomIterator = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/RandomIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.RandomIterator = void 0;
    var _ContainerBase = require_ContainerBase();
    var _throwError = require_throwError();
    var RandomIterator = class extends _ContainerBase.ContainerIterator {
      constructor(t, r) {
        super(r);
        this.o = t;
        if (this.iteratorType === 0) {
          this.pre = function() {
            if (this.o === 0) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o -= 1;
            return this;
          };
          this.next = function() {
            if (this.o === this.container.size()) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o += 1;
            return this;
          };
        } else {
          this.pre = function() {
            if (this.o === this.container.size() - 1) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o += 1;
            return this;
          };
          this.next = function() {
            if (this.o === -1) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o -= 1;
            return this;
          };
        }
      }
      get pointer() {
        return this.container.getElementByPos(this.o);
      }
      set pointer(t) {
        this.container.setElementByPos(this.o, t);
      }
    };
    exports.RandomIterator = RandomIterator;
  }
});

// node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Vector.js
var require_Vector = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = _interopRequireDefault(require_Base());
    var _RandomIterator = require_RandomIterator();
    function _interopRequireDefault(t) {
      return t && t.t ? t : {
        default: t
      };
    }
    var VectorIterator = class extends _RandomIterator.RandomIterator {
      constructor(t, r, e) {
        super(t, e);
        this.container = r;
      }
      copy() {
        return new VectorIterator(this.o, this.container, this.iteratorType);
      }
    };
    var Vector = class extends _Base.default {
      constructor(t = [], r = true) {
        super();
        if (Array.isArray(t)) {
          this.J = r ? [...t] : t;
          this.i = t.length;
        } else {
          this.J = [];
          const r2 = this;
          t.forEach(function(t2) {
            r2.pushBack(t2);
          });
        }
      }
      clear() {
        this.i = 0;
        this.J.length = 0;
      }
      begin() {
        return new VectorIterator(0, this);
      }
      end() {
        return new VectorIterator(this.i, this);
      }
      rBegin() {
        return new VectorIterator(this.i - 1, this, 1);
      }
      rEnd() {
        return new VectorIterator(-1, this, 1);
      }
      front() {
        return this.J[0];
      }
      back() {
        return this.J[this.i - 1];
      }
      getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        return this.J[t];
      }
      eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        this.J.splice(t, 1);
        this.i -= 1;
        return this.i;
      }
      eraseElementByValue(t) {
        let r = 0;
        for (let e = 0; e < this.i; ++e) {
          if (this.J[e] !== t) {
            this.J[r++] = this.J[e];
          }
        }
        this.i = this.J.length = r;
        return this.i;
      }
      eraseElementByIterator(t) {
        const r = t.o;
        t = t.next();
        this.eraseElementByPos(r);
        return t;
      }
      pushBack(t) {
        this.J.push(t);
        this.i += 1;
        return this.i;
      }
      popBack() {
        if (this.i === 0)
          return;
        this.i -= 1;
        return this.J.pop();
      }
      setElementByPos(t, r) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        this.J[t] = r;
      }
      insert(t, r, e = 1) {
        if (t < 0 || t > this.i) {
          throw new RangeError();
        }
        this.J.splice(t, 0, ...new Array(e).fill(r));
        this.i += e;
        return this.i;
      }
      find(t) {
        for (let r = 0; r < this.i; ++r) {
          if (this.J[r] === t) {
            return new VectorIterator(r, this);
          }
        }
        return this.end();
      }
      reverse() {
        this.J.reverse();
      }
      unique() {
        let t = 1;
        for (let r = 1; r < this.i; ++r) {
          if (this.J[r] !== this.J[r - 1]) {
            this.J[t++] = this.J[r];
          }
        }
        this.i = this.J.length = t;
        return this.i;
      }
      sort(t) {
        this.J.sort(t);
      }
      forEach(t) {
        for (let r = 0; r < this.i; ++r) {
          t(this.J[r], r, this);
        }
      }
      [Symbol.iterator]() {
        return function* () {
          yield* this.J;
        }.bind(this)();
      }
    };
    var _default = Vector;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/SequentialContainer/LinkList.js
var require_LinkList = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/LinkList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = _interopRequireDefault(require_Base());
    var _ContainerBase = require_ContainerBase();
    var _throwError = require_throwError();
    function _interopRequireDefault(t) {
      return t && t.t ? t : {
        default: t
      };
    }
    var LinkListIterator = class extends _ContainerBase.ContainerIterator {
      constructor(t, i, s, r) {
        super(r);
        this.o = t;
        this.h = i;
        this.container = s;
        if (this.iteratorType === 0) {
          this.pre = function() {
            if (this.o.L === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L;
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B;
            return this;
          };
        } else {
          this.pre = function() {
            if (this.o.B === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B;
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L;
            return this;
          };
        }
      }
      get pointer() {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.l;
      }
      set pointer(t) {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        this.o.l = t;
      }
      copy() {
        return new LinkListIterator(this.o, this.h, this.container, this.iteratorType);
      }
    };
    var LinkList = class extends _Base.default {
      constructor(t = []) {
        super();
        this.h = {};
        this.p = this._ = this.h.L = this.h.B = this.h;
        const i = this;
        t.forEach(function(t2) {
          i.pushBack(t2);
        });
      }
      V(t) {
        const { L: i, B: s } = t;
        i.B = s;
        s.L = i;
        if (t === this.p) {
          this.p = s;
        }
        if (t === this._) {
          this._ = i;
        }
        this.i -= 1;
      }
      G(t, i) {
        const s = i.B;
        const r = {
          l: t,
          L: i,
          B: s
        };
        i.B = r;
        s.L = r;
        if (i === this.h) {
          this.p = r;
        }
        if (s === this.h) {
          this._ = r;
        }
        this.i += 1;
      }
      clear() {
        this.i = 0;
        this.p = this._ = this.h.L = this.h.B = this.h;
      }
      begin() {
        return new LinkListIterator(this.p, this.h, this);
      }
      end() {
        return new LinkListIterator(this.h, this.h, this);
      }
      rBegin() {
        return new LinkListIterator(this._, this.h, this, 1);
      }
      rEnd() {
        return new LinkListIterator(this.h, this.h, this, 1);
      }
      front() {
        return this.p.l;
      }
      back() {
        return this._.l;
      }
      getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let i = this.p;
        while (t--) {
          i = i.B;
        }
        return i.l;
      }
      eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let i = this.p;
        while (t--) {
          i = i.B;
        }
        this.V(i);
        return this.i;
      }
      eraseElementByValue(t) {
        let i = this.p;
        while (i !== this.h) {
          if (i.l === t) {
            this.V(i);
          }
          i = i.B;
        }
        return this.i;
      }
      eraseElementByIterator(t) {
        const i = t.o;
        if (i === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        t = t.next();
        this.V(i);
        return t;
      }
      pushBack(t) {
        this.G(t, this._);
        return this.i;
      }
      popBack() {
        if (this.i === 0)
          return;
        const t = this._.l;
        this.V(this._);
        return t;
      }
      pushFront(t) {
        this.G(t, this.h);
        return this.i;
      }
      popFront() {
        if (this.i === 0)
          return;
        const t = this.p.l;
        this.V(this.p);
        return t;
      }
      setElementByPos(t, i) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let s = this.p;
        while (t--) {
          s = s.B;
        }
        s.l = i;
      }
      insert(t, i, s = 1) {
        if (t < 0 || t > this.i) {
          throw new RangeError();
        }
        if (s <= 0)
          return this.i;
        if (t === 0) {
          while (s--)
            this.pushFront(i);
        } else if (t === this.i) {
          while (s--)
            this.pushBack(i);
        } else {
          let r = this.p;
          for (let i2 = 1; i2 < t; ++i2) {
            r = r.B;
          }
          const e = r.B;
          this.i += s;
          while (s--) {
            r.B = {
              l: i,
              L: r
            };
            r.B.L = r;
            r = r.B;
          }
          r.B = e;
          e.L = r;
        }
        return this.i;
      }
      find(t) {
        let i = this.p;
        while (i !== this.h) {
          if (i.l === t) {
            return new LinkListIterator(i, this.h, this);
          }
          i = i.B;
        }
        return this.end();
      }
      reverse() {
        if (this.i <= 1)
          return;
        let t = this.p;
        let i = this._;
        let s = 0;
        while (s << 1 < this.i) {
          const r = t.l;
          t.l = i.l;
          i.l = r;
          t = t.B;
          i = i.L;
          s += 1;
        }
      }
      unique() {
        if (this.i <= 1) {
          return this.i;
        }
        let t = this.p;
        while (t !== this.h) {
          let i = t;
          while (i.B !== this.h && i.l === i.B.l) {
            i = i.B;
            this.i -= 1;
          }
          t.B = i.B;
          t.B.L = t;
          t = t.B;
        }
        return this.i;
      }
      sort(t) {
        if (this.i <= 1)
          return;
        const i = [];
        this.forEach(function(t2) {
          i.push(t2);
        });
        i.sort(t);
        let s = this.p;
        i.forEach(function(t2) {
          s.l = t2;
          s = s.B;
        });
      }
      merge(t) {
        const i = this;
        if (this.i === 0) {
          t.forEach(function(t2) {
            i.pushBack(t2);
          });
        } else {
          let s = this.p;
          t.forEach(function(t2) {
            while (s !== i.h && s.l <= t2) {
              s = s.B;
            }
            i.G(t2, s.L);
          });
        }
        return this.i;
      }
      forEach(t) {
        let i = this.p;
        let s = 0;
        while (i !== this.h) {
          t(i.l, s++, this);
          i = i.B;
        }
      }
      [Symbol.iterator]() {
        return function* () {
          if (this.i === 0)
            return;
          let t = this.p;
          while (t !== this.h) {
            yield t.l;
            t = t.B;
          }
        }.bind(this)();
      }
    };
    var _default = LinkList;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Deque.js
var require_Deque = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Deque.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = _interopRequireDefault(require_Base());
    var _RandomIterator = require_RandomIterator();
    function _interopRequireDefault(t) {
      return t && t.t ? t : {
        default: t
      };
    }
    var DequeIterator = class extends _RandomIterator.RandomIterator {
      constructor(t, i, s) {
        super(t, s);
        this.container = i;
      }
      copy() {
        return new DequeIterator(this.o, this.container, this.iteratorType);
      }
    };
    var Deque = class extends _Base.default {
      constructor(t = [], i = 1 << 12) {
        super();
        this.j = 0;
        this.D = 0;
        this.R = 0;
        this.N = 0;
        this.P = 0;
        this.A = [];
        const s = (() => {
          if (typeof t.length === "number")
            return t.length;
          if (typeof t.size === "number")
            return t.size;
          if (typeof t.size === "function")
            return t.size();
          throw new TypeError("Cannot get the length or size of the container");
        })();
        this.F = i;
        this.P = Math.max(Math.ceil(s / this.F), 1);
        for (let t2 = 0; t2 < this.P; ++t2) {
          this.A.push(new Array(this.F));
        }
        const h = Math.ceil(s / this.F);
        this.j = this.R = (this.P >> 1) - (h >> 1);
        this.D = this.N = this.F - s % this.F >> 1;
        const e = this;
        t.forEach(function(t2) {
          e.pushBack(t2);
        });
      }
      T() {
        const t = [];
        const i = Math.max(this.P >> 1, 1);
        for (let s = 0; s < i; ++s) {
          t[s] = new Array(this.F);
        }
        for (let i2 = this.j; i2 < this.P; ++i2) {
          t[t.length] = this.A[i2];
        }
        for (let i2 = 0; i2 < this.R; ++i2) {
          t[t.length] = this.A[i2];
        }
        t[t.length] = [...this.A[this.R]];
        this.j = i;
        this.R = t.length - 1;
        for (let s = 0; s < i; ++s) {
          t[t.length] = new Array(this.F);
        }
        this.A = t;
        this.P = t.length;
      }
      O(t) {
        const i = this.D + t + 1;
        const s = i % this.F;
        let h = s - 1;
        let e = this.j + (i - s) / this.F;
        if (s === 0)
          e -= 1;
        e %= this.P;
        if (h < 0)
          h += this.F;
        return {
          curNodeBucketIndex: e,
          curNodePointerIndex: h
        };
      }
      clear() {
        this.A = [new Array(this.F)];
        this.P = 1;
        this.j = this.R = this.i = 0;
        this.D = this.N = this.F >> 1;
      }
      begin() {
        return new DequeIterator(0, this);
      }
      end() {
        return new DequeIterator(this.i, this);
      }
      rBegin() {
        return new DequeIterator(this.i - 1, this, 1);
      }
      rEnd() {
        return new DequeIterator(-1, this, 1);
      }
      front() {
        if (this.i === 0)
          return;
        return this.A[this.j][this.D];
      }
      back() {
        if (this.i === 0)
          return;
        return this.A[this.R][this.N];
      }
      pushBack(t) {
        if (this.i) {
          if (this.N < this.F - 1) {
            this.N += 1;
          } else if (this.R < this.P - 1) {
            this.R += 1;
            this.N = 0;
          } else {
            this.R = 0;
            this.N = 0;
          }
          if (this.R === this.j && this.N === this.D)
            this.T();
        }
        this.i += 1;
        this.A[this.R][this.N] = t;
        return this.i;
      }
      popBack() {
        if (this.i === 0)
          return;
        const t = this.A[this.R][this.N];
        if (this.i !== 1) {
          if (this.N > 0) {
            this.N -= 1;
          } else if (this.R > 0) {
            this.R -= 1;
            this.N = this.F - 1;
          } else {
            this.R = this.P - 1;
            this.N = this.F - 1;
          }
        }
        this.i -= 1;
        return t;
      }
      pushFront(t) {
        if (this.i) {
          if (this.D > 0) {
            this.D -= 1;
          } else if (this.j > 0) {
            this.j -= 1;
            this.D = this.F - 1;
          } else {
            this.j = this.P - 1;
            this.D = this.F - 1;
          }
          if (this.j === this.R && this.D === this.N)
            this.T();
        }
        this.i += 1;
        this.A[this.j][this.D] = t;
        return this.i;
      }
      popFront() {
        if (this.i === 0)
          return;
        const t = this.A[this.j][this.D];
        if (this.i !== 1) {
          if (this.D < this.F - 1) {
            this.D += 1;
          } else if (this.j < this.P - 1) {
            this.j += 1;
            this.D = 0;
          } else {
            this.j = 0;
            this.D = 0;
          }
        }
        this.i -= 1;
        return t;
      }
      getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        const { curNodeBucketIndex: i, curNodePointerIndex: s } = this.O(t);
        return this.A[i][s];
      }
      setElementByPos(t, i) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        const { curNodeBucketIndex: s, curNodePointerIndex: h } = this.O(t);
        this.A[s][h] = i;
      }
      insert(t, i, s = 1) {
        if (t < 0 || t > this.i) {
          throw new RangeError();
        }
        if (t === 0) {
          while (s--)
            this.pushFront(i);
        } else if (t === this.i) {
          while (s--)
            this.pushBack(i);
        } else {
          const h = [];
          for (let i2 = t; i2 < this.i; ++i2) {
            h.push(this.getElementByPos(i2));
          }
          this.cut(t - 1);
          for (let t2 = 0; t2 < s; ++t2)
            this.pushBack(i);
          for (let t2 = 0; t2 < h.length; ++t2)
            this.pushBack(h[t2]);
        }
        return this.i;
      }
      cut(t) {
        if (t < 0) {
          this.clear();
          return 0;
        }
        const { curNodeBucketIndex: i, curNodePointerIndex: s } = this.O(t);
        this.R = i;
        this.N = s;
        this.i = t + 1;
        return this.i;
      }
      eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        if (t === 0)
          this.popFront();
        else if (t === this.i - 1)
          this.popBack();
        else {
          const i = [];
          for (let s2 = t + 1; s2 < this.i; ++s2) {
            i.push(this.getElementByPos(s2));
          }
          this.cut(t);
          this.popBack();
          const s = this;
          i.forEach(function(t2) {
            s.pushBack(t2);
          });
        }
        return this.i;
      }
      eraseElementByValue(t) {
        if (this.i === 0)
          return 0;
        const i = [];
        for (let s2 = 0; s2 < this.i; ++s2) {
          const h = this.getElementByPos(s2);
          if (h !== t)
            i.push(h);
        }
        const s = i.length;
        for (let t2 = 0; t2 < s; ++t2)
          this.setElementByPos(t2, i[t2]);
        return this.cut(s - 1);
      }
      eraseElementByIterator(t) {
        const i = t.o;
        this.eraseElementByPos(i);
        t = t.next();
        return t;
      }
      find(t) {
        for (let i = 0; i < this.i; ++i) {
          if (this.getElementByPos(i) === t) {
            return new DequeIterator(i, this);
          }
        }
        return this.end();
      }
      reverse() {
        let t = 0;
        let i = this.i - 1;
        while (t < i) {
          const s = this.getElementByPos(t);
          this.setElementByPos(t, this.getElementByPos(i));
          this.setElementByPos(i, s);
          t += 1;
          i -= 1;
        }
      }
      unique() {
        if (this.i <= 1) {
          return this.i;
        }
        let t = 1;
        let i = this.getElementByPos(0);
        for (let s = 1; s < this.i; ++s) {
          const h = this.getElementByPos(s);
          if (h !== i) {
            i = h;
            this.setElementByPos(t++, h);
          }
        }
        while (this.i > t)
          this.popBack();
        return this.i;
      }
      sort(t) {
        const i = [];
        for (let t2 = 0; t2 < this.i; ++t2) {
          i.push(this.getElementByPos(t2));
        }
        i.sort(t);
        for (let t2 = 0; t2 < this.i; ++t2)
          this.setElementByPos(t2, i[t2]);
      }
      shrinkToFit() {
        if (this.i === 0)
          return;
        const t = [];
        this.forEach(function(i) {
          t.push(i);
        });
        this.P = Math.max(Math.ceil(this.i / this.F), 1);
        this.i = this.j = this.R = this.D = this.N = 0;
        this.A = [];
        for (let t2 = 0; t2 < this.P; ++t2) {
          this.A.push(new Array(this.F));
        }
        for (let i = 0; i < t.length; ++i)
          this.pushBack(t[i]);
      }
      forEach(t) {
        for (let i = 0; i < this.i; ++i) {
          t(this.getElementByPos(i), i, this);
        }
      }
      [Symbol.iterator]() {
        return function* () {
          for (let t = 0; t < this.i; ++t) {
            yield this.getElementByPos(t);
          }
        }.bind(this)();
      }
    };
    var _default = Deque;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeNode.js
var require_TreeNode = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.TreeNodeEnableIndex = exports.TreeNode = void 0;
    var TreeNode = class {
      constructor(e, t) {
        this.ee = 1;
        this.u = void 0;
        this.l = void 0;
        this.U = void 0;
        this.W = void 0;
        this.tt = void 0;
        this.u = e;
        this.l = t;
      }
      L() {
        let e = this;
        if (e.ee === 1 && e.tt.tt === e) {
          e = e.W;
        } else if (e.U) {
          e = e.U;
          while (e.W) {
            e = e.W;
          }
        } else {
          let t = e.tt;
          while (t.U === e) {
            e = t;
            t = e.tt;
          }
          e = t;
        }
        return e;
      }
      B() {
        let e = this;
        if (e.W) {
          e = e.W;
          while (e.U) {
            e = e.U;
          }
          return e;
        } else {
          let t = e.tt;
          while (t.W === e) {
            e = t;
            t = e.tt;
          }
          if (e.W !== t) {
            return t;
          } else
            return e;
        }
      }
      te() {
        const e = this.tt;
        const t = this.W;
        const s = t.U;
        if (e.tt === this)
          e.tt = t;
        else if (e.U === this)
          e.U = t;
        else
          e.W = t;
        t.tt = e;
        t.U = this;
        this.tt = t;
        this.W = s;
        if (s)
          s.tt = this;
        return t;
      }
      se() {
        const e = this.tt;
        const t = this.U;
        const s = t.W;
        if (e.tt === this)
          e.tt = t;
        else if (e.U === this)
          e.U = t;
        else
          e.W = t;
        t.tt = e;
        t.W = this;
        this.tt = t;
        this.U = s;
        if (s)
          s.tt = this;
        return t;
      }
    };
    exports.TreeNode = TreeNode;
    var TreeNodeEnableIndex = class extends TreeNode {
      constructor() {
        super(...arguments);
        this.rt = 1;
      }
      te() {
        const e = super.te();
        this.ie();
        e.ie();
        return e;
      }
      se() {
        const e = super.se();
        this.ie();
        e.ie();
        return e;
      }
      ie() {
        this.rt = 1;
        if (this.U) {
          this.rt += this.U.rt;
        }
        if (this.W) {
          this.rt += this.W.rt;
        }
      }
    };
    exports.TreeNodeEnableIndex = TreeNodeEnableIndex;
  }
});

// node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/index.js
var require_Base2 = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _TreeNode = require_TreeNode();
    var _ContainerBase = require_ContainerBase();
    var _throwError = require_throwError();
    var TreeContainer = class extends _ContainerBase.Container {
      constructor(e = function(e2, t2) {
        if (e2 < t2)
          return -1;
        if (e2 > t2)
          return 1;
        return 0;
      }, t = false) {
        super();
        this.Y = void 0;
        this.v = e;
        if (t) {
          this.re = _TreeNode.TreeNodeEnableIndex;
          this.M = function(e2, t2, i) {
            const s = this.ne(e2, t2, i);
            if (s) {
              let e3 = s.tt;
              while (e3 !== this.h) {
                e3.rt += 1;
                e3 = e3.tt;
              }
              const t3 = this.he(s);
              if (t3) {
                const { parentNode: e4, grandParent: i2, curNode: s2 } = t3;
                e4.ie();
                i2.ie();
                s2.ie();
              }
            }
            return this.i;
          };
          this.V = function(e2) {
            let t2 = this.fe(e2);
            while (t2 !== this.h) {
              t2.rt -= 1;
              t2 = t2.tt;
            }
          };
        } else {
          this.re = _TreeNode.TreeNode;
          this.M = function(e2, t2, i) {
            const s = this.ne(e2, t2, i);
            if (s)
              this.he(s);
            return this.i;
          };
          this.V = this.fe;
        }
        this.h = new this.re();
      }
      X(e, t) {
        let i = this.h;
        while (e) {
          const s = this.v(e.u, t);
          if (s < 0) {
            e = e.W;
          } else if (s > 0) {
            i = e;
            e = e.U;
          } else
            return e;
        }
        return i;
      }
      Z(e, t) {
        let i = this.h;
        while (e) {
          const s = this.v(e.u, t);
          if (s <= 0) {
            e = e.W;
          } else {
            i = e;
            e = e.U;
          }
        }
        return i;
      }
      $(e, t) {
        let i = this.h;
        while (e) {
          const s = this.v(e.u, t);
          if (s < 0) {
            i = e;
            e = e.W;
          } else if (s > 0) {
            e = e.U;
          } else
            return e;
        }
        return i;
      }
      rr(e, t) {
        let i = this.h;
        while (e) {
          const s = this.v(e.u, t);
          if (s < 0) {
            i = e;
            e = e.W;
          } else {
            e = e.U;
          }
        }
        return i;
      }
      ue(e) {
        while (true) {
          const t = e.tt;
          if (t === this.h)
            return;
          if (e.ee === 1) {
            e.ee = 0;
            return;
          }
          if (e === t.U) {
            const i = t.W;
            if (i.ee === 1) {
              i.ee = 0;
              t.ee = 1;
              if (t === this.Y) {
                this.Y = t.te();
              } else
                t.te();
            } else {
              if (i.W && i.W.ee === 1) {
                i.ee = t.ee;
                t.ee = 0;
                i.W.ee = 0;
                if (t === this.Y) {
                  this.Y = t.te();
                } else
                  t.te();
                return;
              } else if (i.U && i.U.ee === 1) {
                i.ee = 1;
                i.U.ee = 0;
                i.se();
              } else {
                i.ee = 1;
                e = t;
              }
            }
          } else {
            const i = t.U;
            if (i.ee === 1) {
              i.ee = 0;
              t.ee = 1;
              if (t === this.Y) {
                this.Y = t.se();
              } else
                t.se();
            } else {
              if (i.U && i.U.ee === 1) {
                i.ee = t.ee;
                t.ee = 0;
                i.U.ee = 0;
                if (t === this.Y) {
                  this.Y = t.se();
                } else
                  t.se();
                return;
              } else if (i.W && i.W.ee === 1) {
                i.ee = 1;
                i.W.ee = 0;
                i.te();
              } else {
                i.ee = 1;
                e = t;
              }
            }
          }
        }
      }
      fe(e) {
        if (this.i === 1) {
          this.clear();
          return this.h;
        }
        let t = e;
        while (t.U || t.W) {
          if (t.W) {
            t = t.W;
            while (t.U)
              t = t.U;
          } else {
            t = t.U;
          }
          [e.u, t.u] = [t.u, e.u];
          [e.l, t.l] = [t.l, e.l];
          e = t;
        }
        if (this.h.U === t) {
          this.h.U = t.tt;
        } else if (this.h.W === t) {
          this.h.W = t.tt;
        }
        this.ue(t);
        const i = t.tt;
        if (t === i.U) {
          i.U = void 0;
        } else
          i.W = void 0;
        this.i -= 1;
        this.Y.ee = 0;
        return i;
      }
      oe(e, t) {
        if (e === void 0)
          return false;
        const i = this.oe(e.U, t);
        if (i)
          return true;
        if (t(e))
          return true;
        return this.oe(e.W, t);
      }
      he(e) {
        while (true) {
          const t = e.tt;
          if (t.ee === 0)
            return;
          const i = t.tt;
          if (t === i.U) {
            const s = i.W;
            if (s && s.ee === 1) {
              s.ee = t.ee = 0;
              if (i === this.Y)
                return;
              i.ee = 1;
              e = i;
              continue;
            } else if (e === t.W) {
              e.ee = 0;
              if (e.U)
                e.U.tt = t;
              if (e.W)
                e.W.tt = i;
              t.W = e.U;
              i.U = e.W;
              e.U = t;
              e.W = i;
              if (i === this.Y) {
                this.Y = e;
                this.h.tt = e;
              } else {
                const t2 = i.tt;
                if (t2.U === i) {
                  t2.U = e;
                } else
                  t2.W = e;
              }
              e.tt = i.tt;
              t.tt = e;
              i.tt = e;
              i.ee = 1;
              return {
                parentNode: t,
                grandParent: i,
                curNode: e
              };
            } else {
              t.ee = 0;
              if (i === this.Y) {
                this.Y = i.se();
              } else
                i.se();
              i.ee = 1;
            }
          } else {
            const s = i.U;
            if (s && s.ee === 1) {
              s.ee = t.ee = 0;
              if (i === this.Y)
                return;
              i.ee = 1;
              e = i;
              continue;
            } else if (e === t.U) {
              e.ee = 0;
              if (e.U)
                e.U.tt = i;
              if (e.W)
                e.W.tt = t;
              i.W = e.U;
              t.U = e.W;
              e.U = i;
              e.W = t;
              if (i === this.Y) {
                this.Y = e;
                this.h.tt = e;
              } else {
                const t2 = i.tt;
                if (t2.U === i) {
                  t2.U = e;
                } else
                  t2.W = e;
              }
              e.tt = i.tt;
              t.tt = e;
              i.tt = e;
              i.ee = 1;
              return {
                parentNode: t,
                grandParent: i,
                curNode: e
              };
            } else {
              t.ee = 0;
              if (i === this.Y) {
                this.Y = i.te();
              } else
                i.te();
              i.ee = 1;
            }
          }
          return;
        }
      }
      ne(e, t, i) {
        if (this.Y === void 0) {
          this.i += 1;
          this.Y = new this.re(e, t);
          this.Y.ee = 0;
          this.Y.tt = this.h;
          this.h.tt = this.Y;
          this.h.U = this.Y;
          this.h.W = this.Y;
          return;
        }
        let s;
        const r = this.h.U;
        const n = this.v(r.u, e);
        if (n === 0) {
          r.l = t;
          return;
        } else if (n > 0) {
          r.U = new this.re(e, t);
          r.U.tt = r;
          s = r.U;
          this.h.U = s;
        } else {
          const r2 = this.h.W;
          const n2 = this.v(r2.u, e);
          if (n2 === 0) {
            r2.l = t;
            return;
          } else if (n2 < 0) {
            r2.W = new this.re(e, t);
            r2.W.tt = r2;
            s = r2.W;
            this.h.W = s;
          } else {
            if (i !== void 0) {
              const r3 = i.o;
              if (r3 !== this.h) {
                const i2 = this.v(r3.u, e);
                if (i2 === 0) {
                  r3.l = t;
                  return;
                } else if (i2 > 0) {
                  const i3 = r3.L();
                  const n3 = this.v(i3.u, e);
                  if (n3 === 0) {
                    i3.l = t;
                    return;
                  } else if (n3 < 0) {
                    s = new this.re(e, t);
                    if (i3.W === void 0) {
                      i3.W = s;
                      s.tt = i3;
                    } else {
                      r3.U = s;
                      s.tt = r3;
                    }
                  }
                }
              }
            }
            if (s === void 0) {
              s = this.Y;
              while (true) {
                const i2 = this.v(s.u, e);
                if (i2 > 0) {
                  if (s.U === void 0) {
                    s.U = new this.re(e, t);
                    s.U.tt = s;
                    s = s.U;
                    break;
                  }
                  s = s.U;
                } else if (i2 < 0) {
                  if (s.W === void 0) {
                    s.W = new this.re(e, t);
                    s.W.tt = s;
                    s = s.W;
                    break;
                  }
                  s = s.W;
                } else {
                  s.l = t;
                  return;
                }
              }
            }
          }
        }
        this.i += 1;
        return s;
      }
      I(e, t) {
        while (e) {
          const i = this.v(e.u, t);
          if (i < 0) {
            e = e.W;
          } else if (i > 0) {
            e = e.U;
          } else
            return e;
        }
        return e || this.h;
      }
      clear() {
        this.i = 0;
        this.Y = void 0;
        this.h.tt = void 0;
        this.h.U = this.h.W = void 0;
      }
      updateKeyByIterator(e, t) {
        const i = e.o;
        if (i === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        if (this.i === 1) {
          i.u = t;
          return true;
        }
        if (i === this.h.U) {
          if (this.v(i.B().u, t) > 0) {
            i.u = t;
            return true;
          }
          return false;
        }
        if (i === this.h.W) {
          if (this.v(i.L().u, t) < 0) {
            i.u = t;
            return true;
          }
          return false;
        }
        const s = i.L().u;
        if (this.v(s, t) >= 0)
          return false;
        const r = i.B().u;
        if (this.v(r, t) <= 0)
          return false;
        i.u = t;
        return true;
      }
      eraseElementByPos(e) {
        if (e < 0 || e > this.i - 1) {
          throw new RangeError();
        }
        let t = 0;
        const i = this;
        this.oe(this.Y, function(s) {
          if (e === t) {
            i.V(s);
            return true;
          }
          t += 1;
          return false;
        });
        return this.i;
      }
      eraseElementByKey(e) {
        if (this.i === 0)
          return false;
        const t = this.I(this.Y, e);
        if (t === this.h)
          return false;
        this.V(t);
        return true;
      }
      eraseElementByIterator(e) {
        const t = e.o;
        if (t === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        const i = t.W === void 0;
        const s = e.iteratorType === 0;
        if (s) {
          if (i)
            e.next();
        } else {
          if (!i || t.U === void 0)
            e.next();
        }
        this.V(t);
        return e;
      }
      forEach(e) {
        let t = 0;
        for (const i of this)
          e(i, t++, this);
      }
      getElementByPos(e) {
        if (e < 0 || e > this.i - 1) {
          throw new RangeError();
        }
        let t;
        let i = 0;
        for (const s of this) {
          if (i === e) {
            t = s;
            break;
          }
          i += 1;
        }
        return t;
      }
      getHeight() {
        if (this.i === 0)
          return 0;
        const traversal = function(e) {
          if (!e)
            return 0;
          return Math.max(traversal(e.U), traversal(e.W)) + 1;
        };
        return traversal(this.Y);
      }
    };
    var _default = TreeContainer;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeIterator.js
var require_TreeIterator = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _ContainerBase = require_ContainerBase();
    var _throwError = require_throwError();
    var TreeIterator = class extends _ContainerBase.ContainerIterator {
      constructor(t, r, i) {
        super(i);
        this.o = t;
        this.h = r;
        if (this.iteratorType === 0) {
          this.pre = function() {
            if (this.o === this.h.U) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L();
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B();
            return this;
          };
        } else {
          this.pre = function() {
            if (this.o === this.h.W) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B();
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L();
            return this;
          };
        }
      }
      get index() {
        let t = this.o;
        const r = this.h.tt;
        if (t === this.h) {
          if (r) {
            return r.rt - 1;
          }
          return 0;
        }
        let i = 0;
        if (t.U) {
          i += t.U.rt;
        }
        while (t !== r) {
          const r2 = t.tt;
          if (t === r2.W) {
            i += 1;
            if (r2.U) {
              i += r2.U.rt;
            }
          }
          t = r2;
        }
        return i;
      }
    };
    var _default = TreeIterator;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedSet.js
var require_OrderedSet = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = _interopRequireDefault(require_Base2());
    var _TreeIterator = _interopRequireDefault(require_TreeIterator());
    var _throwError = require_throwError();
    function _interopRequireDefault(e) {
      return e && e.t ? e : {
        default: e
      };
    }
    var OrderedSetIterator = class extends _TreeIterator.default {
      constructor(e, t, r, i) {
        super(e, t, i);
        this.container = r;
      }
      get pointer() {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.u;
      }
      copy() {
        return new OrderedSetIterator(this.o, this.h, this.container, this.iteratorType);
      }
    };
    var OrderedSet = class extends _Base.default {
      constructor(e = [], t, r) {
        super(t, r);
        const i = this;
        e.forEach(function(e2) {
          i.insert(e2);
        });
      }
      *K(e) {
        if (e === void 0)
          return;
        yield* this.K(e.U);
        yield e.u;
        yield* this.K(e.W);
      }
      begin() {
        return new OrderedSetIterator(this.h.U || this.h, this.h, this);
      }
      end() {
        return new OrderedSetIterator(this.h, this.h, this);
      }
      rBegin() {
        return new OrderedSetIterator(this.h.W || this.h, this.h, this, 1);
      }
      rEnd() {
        return new OrderedSetIterator(this.h, this.h, this, 1);
      }
      front() {
        return this.h.U ? this.h.U.u : void 0;
      }
      back() {
        return this.h.W ? this.h.W.u : void 0;
      }
      insert(e, t) {
        return this.M(e, void 0, t);
      }
      find(e) {
        const t = this.I(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
      }
      lowerBound(e) {
        const t = this.X(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
      }
      upperBound(e) {
        const t = this.Z(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
      }
      reverseLowerBound(e) {
        const t = this.$(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
      }
      reverseUpperBound(e) {
        const t = this.rr(this.Y, e);
        return new OrderedSetIterator(t, this.h, this);
      }
      union(e) {
        const t = this;
        e.forEach(function(e2) {
          t.insert(e2);
        });
        return this.i;
      }
      [Symbol.iterator]() {
        return this.K(this.Y);
      }
    };
    var _default = OrderedSet;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedMap.js
var require_OrderedMap = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = _interopRequireDefault(require_Base2());
    var _TreeIterator = _interopRequireDefault(require_TreeIterator());
    var _throwError = require_throwError();
    function _interopRequireDefault(r) {
      return r && r.t ? r : {
        default: r
      };
    }
    var OrderedMapIterator = class extends _TreeIterator.default {
      constructor(r, t, e, s) {
        super(r, t, s);
        this.container = e;
      }
      get pointer() {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        const r = this;
        return new Proxy([], {
          get(t, e) {
            if (e === "0")
              return r.o.u;
            else if (e === "1")
              return r.o.l;
          },
          set(t, e, s) {
            if (e !== "1") {
              throw new TypeError("props must be 1");
            }
            r.o.l = s;
            return true;
          }
        });
      }
      copy() {
        return new OrderedMapIterator(this.o, this.h, this.container, this.iteratorType);
      }
    };
    var OrderedMap = class extends _Base.default {
      constructor(r = [], t, e) {
        super(t, e);
        const s = this;
        r.forEach(function(r2) {
          s.setElement(r2[0], r2[1]);
        });
      }
      *K(r) {
        if (r === void 0)
          return;
        yield* this.K(r.U);
        yield [r.u, r.l];
        yield* this.K(r.W);
      }
      begin() {
        return new OrderedMapIterator(this.h.U || this.h, this.h, this);
      }
      end() {
        return new OrderedMapIterator(this.h, this.h, this);
      }
      rBegin() {
        return new OrderedMapIterator(this.h.W || this.h, this.h, this, 1);
      }
      rEnd() {
        return new OrderedMapIterator(this.h, this.h, this, 1);
      }
      front() {
        if (this.i === 0)
          return;
        const r = this.h.U;
        return [r.u, r.l];
      }
      back() {
        if (this.i === 0)
          return;
        const r = this.h.W;
        return [r.u, r.l];
      }
      lowerBound(r) {
        const t = this.X(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
      }
      upperBound(r) {
        const t = this.Z(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
      }
      reverseLowerBound(r) {
        const t = this.$(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
      }
      reverseUpperBound(r) {
        const t = this.rr(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
      }
      setElement(r, t, e) {
        return this.M(r, t, e);
      }
      find(r) {
        const t = this.I(this.Y, r);
        return new OrderedMapIterator(t, this.h, this);
      }
      getElementByKey(r) {
        const t = this.I(this.Y, r);
        return t.l;
      }
      union(r) {
        const t = this;
        r.forEach(function(r2) {
          t.setElement(r2[0], r2[1]);
        });
        return this.i;
      }
      [Symbol.iterator]() {
        return this.K(this.Y);
      }
    };
    var _default = OrderedMap;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/utils/checkObject.js
var require_checkObject = __commonJS({
  "node_modules/js-sdsl/dist/cjs/utils/checkObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = checkObject;
    function checkObject(e) {
      const t = typeof e;
      return t === "object" && e !== null || t === "function";
    }
  }
});

// node_modules/js-sdsl/dist/cjs/container/HashContainer/Base/index.js
var require_Base3 = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/HashContainer/Base/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.HashContainerIterator = exports.HashContainer = void 0;
    var _ContainerBase = require_ContainerBase();
    var _checkObject = _interopRequireDefault(require_checkObject());
    var _throwError = require_throwError();
    function _interopRequireDefault(t) {
      return t && t.t ? t : {
        default: t
      };
    }
    var HashContainerIterator = class extends _ContainerBase.ContainerIterator {
      constructor(t, e, i) {
        super(i);
        this.o = t;
        this.h = e;
        if (this.iteratorType === 0) {
          this.pre = function() {
            if (this.o.L === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L;
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B;
            return this;
          };
        } else {
          this.pre = function() {
            if (this.o.B === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.B;
            return this;
          };
          this.next = function() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o = this.o.L;
            return this;
          };
        }
      }
    };
    exports.HashContainerIterator = HashContainerIterator;
    var HashContainer = class extends _ContainerBase.Container {
      constructor() {
        super();
        this.H = [];
        this.g = {};
        this.HASH_TAG = Symbol("@@HASH_TAG");
        Object.setPrototypeOf(this.g, null);
        this.h = {};
        this.h.L = this.h.B = this.p = this._ = this.h;
      }
      V(t) {
        const { L: e, B: i } = t;
        e.B = i;
        i.L = e;
        if (t === this.p) {
          this.p = i;
        }
        if (t === this._) {
          this._ = e;
        }
        this.i -= 1;
      }
      M(t, e, i) {
        if (i === void 0)
          i = (0, _checkObject.default)(t);
        let s;
        if (i) {
          const i2 = t[this.HASH_TAG];
          if (i2 !== void 0) {
            this.H[i2].l = e;
            return this.i;
          }
          Object.defineProperty(t, this.HASH_TAG, {
            value: this.H.length,
            configurable: true
          });
          s = {
            u: t,
            l: e,
            L: this._,
            B: this.h
          };
          this.H.push(s);
        } else {
          const i2 = this.g[t];
          if (i2) {
            i2.l = e;
            return this.i;
          }
          s = {
            u: t,
            l: e,
            L: this._,
            B: this.h
          };
          this.g[t] = s;
        }
        if (this.i === 0) {
          this.p = s;
          this.h.B = s;
        } else {
          this._.B = s;
        }
        this._ = s;
        this.h.L = s;
        return ++this.i;
      }
      I(t, e) {
        if (e === void 0)
          e = (0, _checkObject.default)(t);
        if (e) {
          const e2 = t[this.HASH_TAG];
          if (e2 === void 0)
            return this.h;
          return this.H[e2];
        } else {
          return this.g[t] || this.h;
        }
      }
      clear() {
        const t = this.HASH_TAG;
        this.H.forEach(function(e) {
          delete e.u[t];
        });
        this.H = [];
        this.g = {};
        Object.setPrototypeOf(this.g, null);
        this.i = 0;
        this.p = this._ = this.h.L = this.h.B = this.h;
      }
      eraseElementByKey(t, e) {
        let i;
        if (e === void 0)
          e = (0, _checkObject.default)(t);
        if (e) {
          const e2 = t[this.HASH_TAG];
          if (e2 === void 0)
            return false;
          delete t[this.HASH_TAG];
          i = this.H[e2];
          delete this.H[e2];
        } else {
          i = this.g[t];
          if (i === void 0)
            return false;
          delete this.g[t];
        }
        this.V(i);
        return true;
      }
      eraseElementByIterator(t) {
        const e = t.o;
        if (e === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        this.V(e);
        return t.next();
      }
      eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let e = this.p;
        while (t--) {
          e = e.B;
        }
        this.V(e);
        return this.i;
      }
    };
    exports.HashContainer = HashContainer;
  }
});

// node_modules/js-sdsl/dist/cjs/container/HashContainer/HashSet.js
var require_HashSet = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/HashContainer/HashSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = require_Base3();
    var _throwError = require_throwError();
    var HashSetIterator = class extends _Base.HashContainerIterator {
      constructor(t, e, r, s) {
        super(t, e, s);
        this.container = r;
      }
      get pointer() {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.u;
      }
      copy() {
        return new HashSetIterator(this.o, this.h, this.container, this.iteratorType);
      }
    };
    var HashSet = class extends _Base.HashContainer {
      constructor(t = []) {
        super();
        const e = this;
        t.forEach(function(t2) {
          e.insert(t2);
        });
      }
      begin() {
        return new HashSetIterator(this.p, this.h, this);
      }
      end() {
        return new HashSetIterator(this.h, this.h, this);
      }
      rBegin() {
        return new HashSetIterator(this._, this.h, this, 1);
      }
      rEnd() {
        return new HashSetIterator(this.h, this.h, this, 1);
      }
      front() {
        return this.p.u;
      }
      back() {
        return this._.u;
      }
      insert(t, e) {
        return this.M(t, void 0, e);
      }
      getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let e = this.p;
        while (t--) {
          e = e.B;
        }
        return e.u;
      }
      find(t, e) {
        const r = this.I(t, e);
        return new HashSetIterator(r, this.h, this);
      }
      forEach(t) {
        let e = 0;
        let r = this.p;
        while (r !== this.h) {
          t(r.u, e++, this);
          r = r.B;
        }
      }
      [Symbol.iterator]() {
        return function* () {
          let t = this.p;
          while (t !== this.h) {
            yield t.u;
            t = t.B;
          }
        }.bind(this)();
      }
    };
    var _default = HashSet;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/container/HashContainer/HashMap.js
var require_HashMap = __commonJS({
  "node_modules/js-sdsl/dist/cjs/container/HashContainer/HashMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    exports.default = void 0;
    var _Base = require_Base3();
    var _checkObject = _interopRequireDefault(require_checkObject());
    var _throwError = require_throwError();
    function _interopRequireDefault(t) {
      return t && t.t ? t : {
        default: t
      };
    }
    var HashMapIterator = class extends _Base.HashContainerIterator {
      constructor(t, e, r, s) {
        super(t, e, s);
        this.container = r;
      }
      get pointer() {
        if (this.o === this.h) {
          (0, _throwError.throwIteratorAccessError)();
        }
        const t = this;
        return new Proxy([], {
          get(e, r) {
            if (r === "0")
              return t.o.u;
            else if (r === "1")
              return t.o.l;
          },
          set(e, r, s) {
            if (r !== "1") {
              throw new TypeError("props must be 1");
            }
            t.o.l = s;
            return true;
          }
        });
      }
      copy() {
        return new HashMapIterator(this.o, this.h, this.container, this.iteratorType);
      }
    };
    var HashMap = class extends _Base.HashContainer {
      constructor(t = []) {
        super();
        const e = this;
        t.forEach(function(t2) {
          e.setElement(t2[0], t2[1]);
        });
      }
      begin() {
        return new HashMapIterator(this.p, this.h, this);
      }
      end() {
        return new HashMapIterator(this.h, this.h, this);
      }
      rBegin() {
        return new HashMapIterator(this._, this.h, this, 1);
      }
      rEnd() {
        return new HashMapIterator(this.h, this.h, this, 1);
      }
      front() {
        if (this.i === 0)
          return;
        return [this.p.u, this.p.l];
      }
      back() {
        if (this.i === 0)
          return;
        return [this._.u, this._.l];
      }
      setElement(t, e, r) {
        return this.M(t, e, r);
      }
      getElementByKey(t, e) {
        if (e === void 0)
          e = (0, _checkObject.default)(t);
        if (e) {
          const e2 = t[this.HASH_TAG];
          return e2 !== void 0 ? this.H[e2].l : void 0;
        }
        const r = this.g[t];
        return r ? r.l : void 0;
      }
      getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
          throw new RangeError();
        }
        let e = this.p;
        while (t--) {
          e = e.B;
        }
        return [e.u, e.l];
      }
      find(t, e) {
        const r = this.I(t, e);
        return new HashMapIterator(r, this.h, this);
      }
      forEach(t) {
        let e = 0;
        let r = this.p;
        while (r !== this.h) {
          t([r.u, r.l], e++, this);
          r = r.B;
        }
      }
      [Symbol.iterator]() {
        return function* () {
          let t = this.p;
          while (t !== this.h) {
            yield [t.u, t.l];
            t = t.B;
          }
        }.bind(this)();
      }
    };
    var _default = HashMap;
    exports.default = _default;
  }
});

// node_modules/js-sdsl/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/js-sdsl/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    Object.defineProperty(exports, "Deque", {
      enumerable: true,
      get: function() {
        return _Deque.default;
      }
    });
    Object.defineProperty(exports, "HashMap", {
      enumerable: true,
      get: function() {
        return _HashMap.default;
      }
    });
    Object.defineProperty(exports, "HashSet", {
      enumerable: true,
      get: function() {
        return _HashSet.default;
      }
    });
    Object.defineProperty(exports, "LinkList", {
      enumerable: true,
      get: function() {
        return _LinkList.default;
      }
    });
    Object.defineProperty(exports, "OrderedMap", {
      enumerable: true,
      get: function() {
        return _OrderedMap.default;
      }
    });
    Object.defineProperty(exports, "OrderedSet", {
      enumerable: true,
      get: function() {
        return _OrderedSet.default;
      }
    });
    Object.defineProperty(exports, "PriorityQueue", {
      enumerable: true,
      get: function() {
        return _PriorityQueue.default;
      }
    });
    Object.defineProperty(exports, "Queue", {
      enumerable: true,
      get: function() {
        return _Queue.default;
      }
    });
    Object.defineProperty(exports, "Stack", {
      enumerable: true,
      get: function() {
        return _Stack.default;
      }
    });
    Object.defineProperty(exports, "Vector", {
      enumerable: true,
      get: function() {
        return _Vector.default;
      }
    });
    var _Stack = _interopRequireDefault(require_Stack());
    var _Queue = _interopRequireDefault(require_Queue());
    var _PriorityQueue = _interopRequireDefault(require_PriorityQueue());
    var _Vector = _interopRequireDefault(require_Vector());
    var _LinkList = _interopRequireDefault(require_LinkList());
    var _Deque = _interopRequireDefault(require_Deque());
    var _OrderedSet = _interopRequireDefault(require_OrderedSet());
    var _OrderedMap = _interopRequireDefault(require_OrderedMap());
    var _HashSet = _interopRequireDefault(require_HashSet());
    var _HashMap = _interopRequireDefault(require_HashMap());
    function _interopRequireDefault(e) {
      return e && e.t ? e : {
        default: e
      };
    }
  }
});

// node_modules/number-allocator/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/number-allocator/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/number-allocator/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/number-allocator/node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms3();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/number-allocator/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/number-allocator/node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/number-allocator/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/number-allocator/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/number-allocator/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/number-allocator/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/number-allocator/lib/number-allocator.js
var require_number_allocator = __commonJS({
  "node_modules/number-allocator/lib/number-allocator.js"(exports, module2) {
    "use strict";
    var SortedSet = require_cjs().OrderedSet;
    var debugTrace = require_src3()("number-allocator:trace");
    var debugError = require_src3()("number-allocator:error");
    function Interval(low, high) {
      this.low = low;
      this.high = high;
    }
    Interval.prototype.equals = function(other) {
      return this.low === other.low && this.high === other.high;
    };
    Interval.prototype.compare = function(other) {
      if (this.low < other.low && this.high < other.low)
        return -1;
      if (other.low < this.low && other.high < this.low)
        return 1;
      return 0;
    };
    function NumberAllocator(min, max) {
      if (!(this instanceof NumberAllocator)) {
        return new NumberAllocator(min, max);
      }
      this.min = min;
      this.max = max;
      this.ss = new SortedSet([], (lhs, rhs) => {
        return lhs.compare(rhs);
      });
      debugTrace("Create");
      this.clear();
    }
    NumberAllocator.prototype.firstVacant = function() {
      if (this.ss.size() === 0)
        return null;
      return this.ss.front().low;
    };
    NumberAllocator.prototype.alloc = function() {
      if (this.ss.size() === 0) {
        debugTrace("alloc():empty");
        return null;
      }
      const it = this.ss.begin();
      const low = it.pointer.low;
      const high = it.pointer.high;
      const num = low;
      if (num + 1 <= high) {
        this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
      } else {
        this.ss.eraseElementByPos(0);
      }
      debugTrace("alloc():" + num);
      return num;
    };
    NumberAllocator.prototype.use = function(num) {
      const key = new Interval(num, num);
      const it = this.ss.lowerBound(key);
      if (!it.equals(this.ss.end())) {
        const low = it.pointer.low;
        const high = it.pointer.high;
        if (it.pointer.equals(key)) {
          this.ss.eraseElementByIterator(it);
          debugTrace("use():" + num);
          return true;
        }
        if (low > num)
          return false;
        if (low === num) {
          this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
          debugTrace("use():" + num);
          return true;
        }
        if (high === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, high - 1));
          debugTrace("use():" + num);
          return true;
        }
        this.ss.updateKeyByIterator(it, new Interval(num + 1, high));
        this.ss.insert(new Interval(low, num - 1));
        debugTrace("use():" + num);
        return true;
      }
      debugTrace("use():failed");
      return false;
    };
    NumberAllocator.prototype.free = function(num) {
      if (num < this.min || num > this.max) {
        debugError("free():" + num + " is out of range");
        return;
      }
      const key = new Interval(num, num);
      const it = this.ss.upperBound(key);
      if (it.equals(this.ss.end())) {
        if (it.equals(this.ss.begin())) {
          this.ss.insert(key);
          return;
        }
        it.pre();
        const low = it.pointer.high;
        const high = it.pointer.high;
        if (high + 1 === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, num));
        } else {
          this.ss.insert(key);
        }
      } else {
        if (it.equals(this.ss.begin())) {
          if (num + 1 === it.pointer.low) {
            const high = it.pointer.high;
            this.ss.updateKeyByIterator(it, new Interval(num, high));
          } else {
            this.ss.insert(key);
          }
        } else {
          const rLow = it.pointer.low;
          const rHigh = it.pointer.high;
          it.pre();
          const lLow = it.pointer.low;
          const lHigh = it.pointer.high;
          if (lHigh + 1 === num) {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it);
              this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));
            } else {
              this.ss.updateKeyByIterator(it, new Interval(lLow, num));
            }
          } else {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it.next());
              this.ss.insert(new Interval(num, rHigh));
            } else {
              this.ss.insert(key);
            }
          }
        }
      }
      debugTrace("free():" + num);
    };
    NumberAllocator.prototype.clear = function() {
      debugTrace("clear()");
      this.ss.clear();
      this.ss.insert(new Interval(this.min, this.max));
    };
    NumberAllocator.prototype.intervalCount = function() {
      return this.ss.size();
    };
    NumberAllocator.prototype.dump = function() {
      console.log("length:" + this.ss.size());
      for (const element of this.ss) {
        console.log(element);
      }
    };
    module2.exports = NumberAllocator;
  }
});

// node_modules/number-allocator/index.js
var require_number_allocator2 = __commonJS({
  "node_modules/number-allocator/index.js"(exports, module2) {
    var NumberAllocator = require_number_allocator();
    module2.exports.NumberAllocator = NumberAllocator;
  }
});

// node_modules/mqtt/build/lib/topic-alias-send.js
var require_topic_alias_send = __commonJS({
  "node_modules/mqtt/build/lib/topic-alias-send.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lru_cache_1 = require_commonjs();
    var number_allocator_1 = require_number_allocator2();
    var TopicAliasSend = class {
      constructor(max) {
        if (max > 0) {
          this.aliasToTopic = new lru_cache_1.LRUCache({ max });
          this.topicToAlias = {};
          this.numberAllocator = new number_allocator_1.NumberAllocator(1, max);
          this.max = max;
          this.length = 0;
        }
      }
      put(topic, alias) {
        if (alias === 0 || alias > this.max) {
          return false;
        }
        const entry = this.aliasToTopic.get(alias);
        if (entry) {
          delete this.topicToAlias[entry];
        }
        this.aliasToTopic.set(alias, topic);
        this.topicToAlias[topic] = alias;
        this.numberAllocator.use(alias);
        this.length = this.aliasToTopic.size;
        return true;
      }
      getTopicByAlias(alias) {
        return this.aliasToTopic.get(alias);
      }
      getAliasByTopic(topic) {
        const alias = this.topicToAlias[topic];
        if (typeof alias !== "undefined") {
          this.aliasToTopic.get(alias);
        }
        return alias;
      }
      clear() {
        this.aliasToTopic.clear();
        this.topicToAlias = {};
        this.numberAllocator.clear();
        this.length = 0;
      }
      getLruAlias() {
        const alias = this.numberAllocator.firstVacant();
        if (alias)
          return alias;
        return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
      }
    };
    exports.default = TopicAliasSend;
  }
});

// node_modules/mqtt/build/lib/handlers/connack.js
var require_connack = __commonJS({
  "node_modules/mqtt/build/lib/handlers/connack.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ack_1 = require_ack();
    var topic_alias_send_1 = __importDefault(require_topic_alias_send());
    var shared_1 = require_shared();
    var handleConnack = (client, packet) => {
      client.log("_handleConnack");
      const { options } = client;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      clearTimeout(client["connackTimer"]);
      delete client["topicAliasSend"];
      if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
          if (packet.properties.topicAliasMaximum > 65535) {
            client.emit("error", new Error("topicAliasMaximum from broker is out of range"));
            return;
          }
          if (packet.properties.topicAliasMaximum > 0) {
            client["topicAliasSend"] = new topic_alias_send_1.default(packet.properties.topicAliasMaximum);
          }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
          options.keepalive = packet.properties.serverKeepAlive;
        }
        if (packet.properties.maximumPacketSize) {
          if (!options.properties) {
            options.properties = {};
          }
          options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
        }
      }
      if (rc === 0) {
        client.reconnecting = false;
        client["_onConnect"](packet);
      } else if (rc > 0) {
        const err = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
        client.emit("error", err);
      }
    };
    exports.default = handleConnack;
  }
});

// node_modules/mqtt/build/lib/handlers/pubrel.js
var require_pubrel = __commonJS({
  "node_modules/mqtt/build/lib/handlers/pubrel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var handlePubrel = (client, packet, done) => {
      client.log("handling pubrel packet");
      const callback = typeof done !== "undefined" ? done : client.noop;
      const { messageId } = packet;
      const comp = { cmd: "pubcomp", messageId };
      client.incomingStore.get(packet, (err, pub) => {
        if (!err) {
          client.emit("message", pub.topic, pub.payload, pub);
          client.handleMessage(pub, (err2) => {
            if (err2) {
              return callback(err2);
            }
            client.incomingStore.del(pub, client.noop);
            client["_sendPacket"](comp, callback);
          });
        } else {
          client["_sendPacket"](comp, callback);
        }
      });
    };
    exports.default = handlePubrel;
  }
});

// node_modules/mqtt/build/lib/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/mqtt/build/lib/handlers/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var publish_1 = __importDefault(require_publish());
    var auth_1 = __importDefault(require_auth());
    var connack_1 = __importDefault(require_connack());
    var ack_1 = __importDefault(require_ack());
    var pubrel_1 = __importDefault(require_pubrel());
    var handle = (client, packet, done) => {
      const { options } = client;
      if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
        client.emit("error", new Error(`exceeding packets size ${packet.cmd}`));
        client.end({
          reasonCode: 149,
          properties: { reasonString: "Maximum packet size was exceeded" }
        });
        return client;
      }
      client.log("_handlePacket :: emitting packetreceive");
      client.emit("packetreceive", packet);
      switch (packet.cmd) {
        case "publish":
          (0, publish_1.default)(client, packet, done);
          break;
        case "puback":
        case "pubrec":
        case "pubcomp":
        case "suback":
        case "unsuback":
          client.reschedulePing();
          (0, ack_1.default)(client, packet);
          done();
          break;
        case "pubrel":
          client.reschedulePing();
          (0, pubrel_1.default)(client, packet, done);
          break;
        case "connack":
          (0, connack_1.default)(client, packet);
          done();
          break;
        case "auth":
          client.reschedulePing();
          (0, auth_1.default)(client, packet);
          done();
          break;
        case "pingresp":
          client.log("_handlePacket :: received pingresp");
          client.reschedulePing(true);
          done();
          break;
        case "disconnect":
          client.emit("disconnect", packet);
          done();
          break;
        default:
          client.log("_handlePacket :: unknown command");
          done();
          break;
      }
    };
    exports.default = handle;
  }
});

// node_modules/mqtt/build/lib/TypedEmitter.js
var require_TypedEmitter = __commonJS({
  "node_modules/mqtt/build/lib/TypedEmitter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypedEventEmitter = void 0;
    var events_1 = __importDefault(require("events"));
    var shared_1 = require_shared();
    var TypedEventEmitter = class {
    };
    exports.TypedEventEmitter = TypedEventEmitter;
    (0, shared_1.applyMixin)(TypedEventEmitter, events_1.default);
  }
});

// node_modules/mqtt/build/lib/is-browser.js
var require_is_browser = __commonJS({
  "node_modules/mqtt/build/lib/is-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReactNativeBrowser = exports.isWebWorker = void 0;
    var isStandardBrowserEnv = () => {
      var _a;
      if (typeof window !== "undefined") {
        const electronRenderCheck = typeof navigator !== "undefined" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.toLowerCase().indexOf(" electron/")) > -1;
        if (electronRenderCheck && (process === null || process === void 0 ? void 0 : process.versions)) {
          const electronMainCheck = Object.prototype.hasOwnProperty.call(process.versions, "electron");
          return !electronMainCheck;
        }
        return typeof window.document !== "undefined";
      }
      return false;
    };
    var isWebWorkerEnv = () => {
      var _a, _b;
      return Boolean(typeof self === "object" && ((_b = (_a = self === null || self === void 0 ? void 0 : self.constructor) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.includes("WorkerGlobalScope")));
    };
    var isReactNativeEnv = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var isBrowser = isStandardBrowserEnv() || isWebWorkerEnv() || isReactNativeEnv();
    exports.isWebWorker = isWebWorkerEnv();
    exports.isReactNativeBrowser = isReactNativeEnv();
    exports.default = isBrowser;
  }
});

// node_modules/fast-unique-numbers/build/node/factories/add-unique-number.js
var require_add_unique_number = __commonJS({
  "node_modules/fast-unique-numbers/build/node/factories/add-unique-number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createAddUniqueNumber = void 0;
    var createAddUniqueNumber = (generateUniqueNumber) => {
      return (set) => {
        const number = generateUniqueNumber(set);
        set.add(number);
        return number;
      };
    };
    exports.createAddUniqueNumber = createAddUniqueNumber;
  }
});

// node_modules/fast-unique-numbers/build/node/factories/cache.js
var require_cache = __commonJS({
  "node_modules/fast-unique-numbers/build/node/factories/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCache = void 0;
    var createCache = (lastNumberWeakMap) => {
      return (collection, nextNumber) => {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };
    exports.createCache = createCache;
  }
});

// node_modules/fast-unique-numbers/build/node/factories/generate-unique-number.js
var require_generate_unique_number = __commonJS({
  "node_modules/fast-unique-numbers/build/node/factories/generate-unique-number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createGenerateUniqueNumber = void 0;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
    var createGenerateUniqueNumber = (cache, lastNumberWeakMap) => {
      return (collection) => {
        const lastNumber = lastNumberWeakMap.get(collection);
        let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache(collection, nextNumber);
        }
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
          }
          return cache(collection, nextNumber);
        }
        if (collection.size > MAX_SAFE_INTEGER) {
          throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
        }
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
        }
        return cache(collection, nextNumber);
      };
    };
    exports.createGenerateUniqueNumber = createGenerateUniqueNumber;
  }
});

// node_modules/fast-unique-numbers/build/node/types/add-unique-number-factory.js
var require_add_unique_number_factory = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/add-unique-number-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/add-unique-number-function.js
var require_add_unique_number_function = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/add-unique-number-function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/cache-factory.js
var require_cache_factory = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/cache-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/cache-function.js
var require_cache_function = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/cache-function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/generate-unique-number-factory.js
var require_generate_unique_number_factory = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/generate-unique-number-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/generate-unique-number-function.js
var require_generate_unique_number_function = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/generate-unique-number-function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/fast-unique-numbers/build/node/types/index.js
var require_types = __commonJS({
  "node_modules/fast-unique-numbers/build/node/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _addUniqueNumberFactory = require_add_unique_number_factory();
    Object.keys(_addUniqueNumberFactory).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _addUniqueNumberFactory[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _addUniqueNumberFactory[key];
        }
      });
    });
    var _addUniqueNumberFunction = require_add_unique_number_function();
    Object.keys(_addUniqueNumberFunction).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _addUniqueNumberFunction[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _addUniqueNumberFunction[key];
        }
      });
    });
    var _cacheFactory = require_cache_factory();
    Object.keys(_cacheFactory).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _cacheFactory[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _cacheFactory[key];
        }
      });
    });
    var _cacheFunction = require_cache_function();
    Object.keys(_cacheFunction).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _cacheFunction[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _cacheFunction[key];
        }
      });
    });
    var _generateUniqueNumberFactory = require_generate_unique_number_factory();
    Object.keys(_generateUniqueNumberFactory).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _generateUniqueNumberFactory[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generateUniqueNumberFactory[key];
        }
      });
    });
    var _generateUniqueNumberFunction = require_generate_unique_number_function();
    Object.keys(_generateUniqueNumberFunction).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _generateUniqueNumberFunction[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _generateUniqueNumberFunction[key];
        }
      });
    });
  }
});

// node_modules/fast-unique-numbers/build/node/module.js
var require_module = __commonJS({
  "node_modules/fast-unique-numbers/build/node/module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      addUniqueNumber: true,
      generateUniqueNumber: true
    };
    exports.generateUniqueNumber = exports.addUniqueNumber = void 0;
    var _addUniqueNumber = require_add_unique_number();
    var _cache = require_cache();
    var _generateUniqueNumber = require_generate_unique_number();
    var _index = require_types();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _index[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
    var cache = (0, _cache.createCache)(LAST_NUMBER_WEAK_MAP);
    var generateUniqueNumber = exports.generateUniqueNumber = (0, _generateUniqueNumber.createGenerateUniqueNumber)(cache, LAST_NUMBER_WEAK_MAP);
    var addUniqueNumber = exports.addUniqueNumber = (0, _addUniqueNumber.createAddUniqueNumber)(generateUniqueNumber);
  }
});

// node_modules/worker-timers-broker/build/es5/bundle.js
var require_bundle = __commonJS({
  "node_modules/worker-timers-broker/build/es5/bundle.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_module()) : typeof define === "function" && define.amd ? define(["exports", "fast-unique-numbers"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.workerTimersBroker = {}, global2.fastUniqueNumbers));
    })(exports, function(exports2, fastUniqueNumbers) {
      "use strict";
      var isCallNotification = function isCallNotification2(message) {
        return message.method !== void 0 && message.method === "call";
      };
      var isClearResponse = function isClearResponse2(message) {
        return message.error === null && typeof message.id === "number";
      };
      var load = function load2(url) {
        var scheduledIntervalFunctions = /* @__PURE__ */ new Map([[0, function() {
        }]]);
        var scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, function() {
        }]]);
        var unrespondedRequests = /* @__PURE__ */ new Map();
        var worker = new Worker(url);
        worker.addEventListener("message", function(_ref) {
          var data = _ref.data;
          if (isCallNotification(data)) {
            var _data$params = data.params, timerId = _data$params.timerId, timerType = _data$params.timerType;
            if (timerType === "interval") {
              var idOrFunc = scheduledIntervalFunctions.get(timerId);
              if (typeof idOrFunc === "number") {
                var timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
                  throw new Error("The timer is in an undefined state.");
                }
              } else if (typeof idOrFunc !== "undefined") {
                idOrFunc();
              } else {
                throw new Error("The timer is in an undefined state.");
              }
            } else if (timerType === "timeout") {
              var _idOrFunc = scheduledTimeoutFunctions.get(timerId);
              if (typeof _idOrFunc === "number") {
                var _timerIdAndTimerType = unrespondedRequests.get(_idOrFunc);
                if (_timerIdAndTimerType === void 0 || _timerIdAndTimerType.timerId !== timerId || _timerIdAndTimerType.timerType !== timerType) {
                  throw new Error("The timer is in an undefined state.");
                }
              } else if (typeof _idOrFunc !== "undefined") {
                _idOrFunc();
                scheduledTimeoutFunctions["delete"](timerId);
              } else {
                throw new Error("The timer is in an undefined state.");
              }
            }
          } else if (isClearResponse(data)) {
            var id = data.id;
            var _timerIdAndTimerType2 = unrespondedRequests.get(id);
            if (_timerIdAndTimerType2 === void 0) {
              throw new Error("The timer is in an undefined state.");
            }
            var _timerId = _timerIdAndTimerType2.timerId, _timerType = _timerIdAndTimerType2.timerType;
            unrespondedRequests["delete"](id);
            if (_timerType === "interval") {
              scheduledIntervalFunctions["delete"](_timerId);
            } else {
              scheduledTimeoutFunctions["delete"](_timerId);
            }
          } else {
            var message = data.error.message;
            throw new Error(message);
          }
        });
        var clearInterval2 = function clearInterval3(timerId) {
          var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
          unrespondedRequests.set(id, {
            timerId,
            timerType: "interval"
          });
          scheduledIntervalFunctions.set(timerId, id);
          worker.postMessage({
            id,
            method: "clear",
            params: {
              timerId,
              timerType: "interval"
            }
          });
        };
        var clearTimeout2 = function clearTimeout3(timerId) {
          var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
          unrespondedRequests.set(id, {
            timerId,
            timerType: "timeout"
          });
          scheduledTimeoutFunctions.set(timerId, id);
          worker.postMessage({
            id,
            method: "clear",
            params: {
              timerId,
              timerType: "timeout"
            }
          });
        };
        var setInterval2 = function setInterval3(func) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledIntervalFunctions);
          scheduledIntervalFunctions.set(timerId, function() {
            func();
            if (typeof scheduledIntervalFunctions.get(timerId) === "function") {
              worker.postMessage({
                id: null,
                method: "set",
                params: {
                  delay,
                  now: performance.now(),
                  timerId,
                  timerType: "interval"
                }
              });
            }
          });
          worker.postMessage({
            id: null,
            method: "set",
            params: {
              delay,
              now: performance.now(),
              timerId,
              timerType: "interval"
            }
          });
          return timerId;
        };
        var setTimeout2 = function setTimeout3(func) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledTimeoutFunctions);
          scheduledTimeoutFunctions.set(timerId, func);
          worker.postMessage({
            id: null,
            method: "set",
            params: {
              delay,
              now: performance.now(),
              timerId,
              timerType: "timeout"
            }
          });
          return timerId;
        };
        return {
          clearInterval: clearInterval2,
          clearTimeout: clearTimeout2,
          setInterval: setInterval2,
          setTimeout: setTimeout2
        };
      };
      exports2.load = load;
    });
  }
});

// node_modules/worker-timers/build/es5/bundle.js
var require_bundle2 = __commonJS({
  "node_modules/worker-timers/build/es5/bundle.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_bundle()) : typeof define === "function" && define.amd ? define(["exports", "worker-timers-broker"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.workerTimers = {}, global2.workerTimersBroker));
    })(exports, function(exports2, workerTimersBroker) {
      "use strict";
      var createLoadOrReturnBroker = function createLoadOrReturnBroker2(loadBroker, worker2) {
        var broker = null;
        return function() {
          if (broker !== null) {
            return broker;
          }
          var blob = new Blob([worker2], {
            type: "application/javascript; charset=utf-8"
          });
          var url = URL.createObjectURL(blob);
          broker = loadBroker(url);
          setTimeout(function() {
            return URL.revokeObjectURL(url);
          });
          return broker;
        };
      };
      var worker = `(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error('The given type "'.concat(c,'" is not supported'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error('The given method "'.concat(t.method,'" is not supported'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error('The given type "'.concat(v,'" is not supported'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();`;
      var loadOrReturnBroker = createLoadOrReturnBroker(workerTimersBroker.load, worker);
      var clearInterval2 = function clearInterval3(timerId) {
        return loadOrReturnBroker().clearInterval(timerId);
      };
      var clearTimeout2 = function clearTimeout3(timerId) {
        return loadOrReturnBroker().clearTimeout(timerId);
      };
      var setInterval2 = function setInterval3() {
        var _loadOrReturnBroker;
        return (_loadOrReturnBroker = loadOrReturnBroker()).setInterval.apply(_loadOrReturnBroker, arguments);
      };
      var setTimeout$1 = function setTimeout2() {
        var _loadOrReturnBroker2;
        return (_loadOrReturnBroker2 = loadOrReturnBroker()).setTimeout.apply(_loadOrReturnBroker2, arguments);
      };
      exports2.clearInterval = clearInterval2;
      exports2.clearTimeout = clearTimeout2;
      exports2.setInterval = setInterval2;
      exports2.setTimeout = setTimeout$1;
    });
  }
});

// node_modules/mqtt/build/lib/get-timer.js
var require_get_timer = __commonJS({
  "node_modules/mqtt/build/lib/get-timer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_browser_1 = __importStar(require_is_browser());
    var worker_timers_1 = require_bundle2();
    var workerTimer = {
      set: worker_timers_1.setInterval,
      clear: worker_timers_1.clearInterval
    };
    var nativeTimer = {
      set: (func, time) => setInterval(func, time),
      clear: (timerId) => clearInterval(timerId)
    };
    var getTimer = (variant) => {
      switch (variant) {
        case "native": {
          return nativeTimer;
        }
        case "worker": {
          return workerTimer;
        }
        case "auto":
        default: {
          return is_browser_1.default && !is_browser_1.isWebWorker && !is_browser_1.isReactNativeBrowser ? workerTimer : nativeTimer;
        }
      }
    };
    exports.default = getTimer;
  }
});

// node_modules/mqtt/build/lib/KeepaliveManager.js
var require_KeepaliveManager = __commonJS({
  "node_modules/mqtt/build/lib/KeepaliveManager.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var get_timer_1 = __importDefault(require_get_timer());
    var KeepaliveManager = class {
      get keepaliveTimeoutTimestamp() {
        return this._keepaliveTimeoutTimestamp;
      }
      get intervalEvery() {
        return this._intervalEvery;
      }
      get keepalive() {
        return this._keepalive;
      }
      constructor(client, variant) {
        this.destroyed = false;
        this.client = client;
        this.timer = typeof variant === "object" && "set" in variant && "clear" in variant ? variant : (0, get_timer_1.default)(variant);
        this.setKeepalive(client.options.keepalive);
      }
      clear() {
        if (this.timerId) {
          this.timer.clear(this.timerId);
          this.timerId = null;
        }
      }
      setKeepalive(value) {
        value *= 1e3;
        if (isNaN(value) || value <= 0 || value > 2147483647) {
          throw new Error(`Keepalive value must be an integer between 0 and 2147483647. Provided value is ${value}`);
        }
        this._keepalive = value;
        this.reschedule();
        this.client["log"](`KeepaliveManager: set keepalive to ${value}ms`);
      }
      destroy() {
        this.clear();
        this.destroyed = true;
      }
      reschedule() {
        if (this.destroyed) {
          return;
        }
        this.clear();
        this.counter = 0;
        const keepAliveTimeout = Math.ceil(this._keepalive * 1.5);
        this._keepaliveTimeoutTimestamp = Date.now() + keepAliveTimeout;
        this._intervalEvery = Math.ceil(this._keepalive / 2);
        this.timerId = this.timer.set(() => {
          if (this.destroyed) {
            return;
          }
          this.counter += 1;
          if (this.counter === 2) {
            this.client.sendPing();
          } else if (this.counter > 2) {
            this.client.onKeepaliveTimeout();
          }
        }, this._intervalEvery);
      }
    };
    exports.default = KeepaliveManager;
  }
});

// node_modules/mqtt/build/lib/client.js
var require_client = __commonJS({
  "node_modules/mqtt/build/lib/client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var topic_alias_recv_1 = __importDefault(require_topic_alias_recv());
    var mqtt_packet_1 = __importDefault(require_mqtt());
    var default_message_id_provider_1 = __importDefault(require_default_message_id_provider());
    var readable_stream_1 = require_ours();
    var default_1 = __importDefault(require_default());
    var validations = __importStar(require_validations());
    var debug_1 = __importDefault(require_src2());
    var store_1 = __importDefault(require_store());
    var handlers_1 = __importDefault(require_handlers());
    var shared_1 = require_shared();
    var TypedEmitter_1 = require_TypedEmitter();
    var KeepaliveManager_1 = __importDefault(require_KeepaliveManager());
    var is_browser_1 = __importStar(require_is_browser());
    var setImmediate2 = globalThis.setImmediate || ((...args) => {
      const callback = args.shift();
      (0, shared_1.nextTick)(() => {
        callback(...args);
      });
    });
    var defaultConnectOptions = {
      keepalive: 60,
      reschedulePings: true,
      protocolId: "MQTT",
      protocolVersion: 4,
      reconnectPeriod: 1e3,
      connectTimeout: 30 * 1e3,
      clean: true,
      resubscribe: true,
      writeCache: true,
      timerVariant: "auto"
    };
    var MqttClient = class extends TypedEmitter_1.TypedEventEmitter {
      static defaultId() {
        return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
      }
      constructor(streamBuilder, options) {
        super();
        this.options = options || {};
        for (const k in defaultConnectOptions) {
          if (typeof this.options[k] === "undefined") {
            this.options[k] = defaultConnectOptions[k];
          } else {
            this.options[k] = options[k];
          }
        }
        this.log = this.options.log || (0, debug_1.default)("mqttjs:client");
        this.noop = this._noop.bind(this);
        this.log("MqttClient :: version:", MqttClient.VERSION);
        if (is_browser_1.isWebWorker) {
          this.log("MqttClient :: environment", "webworker");
        } else {
          this.log("MqttClient :: environment", is_browser_1.default ? "browser" : "node");
        }
        this.log("MqttClient :: options.protocol", options.protocol);
        this.log("MqttClient :: options.protocolVersion", options.protocolVersion);
        this.log("MqttClient :: options.username", options.username);
        this.log("MqttClient :: options.keepalive", options.keepalive);
        this.log("MqttClient :: options.reconnectPeriod", options.reconnectPeriod);
        this.log("MqttClient :: options.rejectUnauthorized", options.rejectUnauthorized);
        this.log("MqttClient :: options.properties.topicAliasMaximum", options.properties ? options.properties.topicAliasMaximum : void 0);
        this.options.clientId = typeof options.clientId === "string" ? options.clientId : MqttClient.defaultId();
        this.log("MqttClient :: clientId", this.options.clientId);
        this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : (...args) => {
          args[3](null, 0);
        };
        if (!this.options.writeCache) {
          mqtt_packet_1.default.writeToStream.cacheNumbers = false;
        }
        this.streamBuilder = streamBuilder;
        this.messageIdProvider = typeof this.options.messageIdProvider === "undefined" ? new default_message_id_provider_1.default() : this.options.messageIdProvider;
        this.outgoingStore = options.outgoingStore || new store_1.default();
        this.incomingStore = options.incomingStore || new store_1.default();
        this.queueQoSZero = options.queueQoSZero === void 0 ? true : options.queueQoSZero;
        this._resubscribeTopics = {};
        this.messageIdToTopic = {};
        this.keepaliveManager = null;
        this.connected = false;
        this.disconnecting = false;
        this.reconnecting = false;
        this.queue = [];
        this.connackTimer = null;
        this.reconnectTimer = null;
        this._storeProcessing = false;
        this._packetIdsDuringStoreProcessing = {};
        this._storeProcessingQueue = [];
        this.outgoing = {};
        this._firstConnection = true;
        if (options.properties && options.properties.topicAliasMaximum > 0) {
          if (options.properties.topicAliasMaximum > 65535) {
            this.log("MqttClient :: options.properties.topicAliasMaximum is out of range");
          } else {
            this.topicAliasRecv = new topic_alias_recv_1.default(options.properties.topicAliasMaximum);
          }
        }
        this.on("connect", () => {
          const { queue } = this;
          const deliver = () => {
            const entry = queue.shift();
            this.log("deliver :: entry %o", entry);
            let packet = null;
            if (!entry) {
              this._resubscribe();
              return;
            }
            packet = entry.packet;
            this.log("deliver :: call _sendPacket for %o", packet);
            let send = true;
            if (packet.messageId && packet.messageId !== 0) {
              if (!this.messageIdProvider.register(packet.messageId)) {
                send = false;
              }
            }
            if (send) {
              this._sendPacket(packet, (err) => {
                if (entry.cb) {
                  entry.cb(err);
                }
                deliver();
              });
            } else {
              this.log("messageId: %d has already used. The message is skipped and removed.", packet.messageId);
              deliver();
            }
          };
          this.log("connect :: sending queued packets");
          deliver();
        });
        this.on("close", () => {
          this.log("close :: connected set to `false`");
          this.connected = false;
          this.log("close :: clearing connackTimer");
          clearTimeout(this.connackTimer);
          this._destroyKeepaliveManager();
          if (this.topicAliasRecv) {
            this.topicAliasRecv.clear();
          }
          this.log("close :: calling _setupReconnect");
          this._setupReconnect();
        });
        if (!this.options.manualConnect) {
          this.log("MqttClient :: setting up stream");
          this.connect();
        }
      }
      handleAuth(packet, callback) {
        callback();
      }
      handleMessage(packet, callback) {
        callback();
      }
      _nextId() {
        return this.messageIdProvider.allocate();
      }
      getLastMessageId() {
        return this.messageIdProvider.getLastAllocated();
      }
      connect() {
        var _a;
        const writable = new readable_stream_1.Writable();
        const parser = mqtt_packet_1.default.parser(this.options);
        let completeParse = null;
        const packets = [];
        this.log("connect :: calling method to clear reconnect");
        this._clearReconnect();
        if (this.disconnected && !this.reconnecting) {
          this.incomingStore = this.options.incomingStore || new store_1.default();
          this.outgoingStore = this.options.outgoingStore || new store_1.default();
          this.disconnecting = false;
          this.disconnected = false;
        }
        this.log("connect :: using streamBuilder provided to client to create stream");
        this.stream = this.streamBuilder(this);
        parser.on("packet", (packet) => {
          this.log("parser :: on packet push to packets array.");
          packets.push(packet);
        });
        const work = () => {
          this.log("work :: getting next packet in queue");
          const packet = packets.shift();
          if (packet) {
            this.log("work :: packet pulled from queue");
            (0, handlers_1.default)(this, packet, nextTickWork);
          } else {
            this.log("work :: no packets in queue");
            const done = completeParse;
            completeParse = null;
            this.log("work :: done flag is %s", !!done);
            if (done)
              done();
          }
        };
        const nextTickWork = () => {
          if (packets.length) {
            (0, shared_1.nextTick)(work);
          } else {
            const done = completeParse;
            completeParse = null;
            done();
          }
        };
        writable._write = (buf, enc, done) => {
          completeParse = done;
          this.log("writable stream :: parsing buffer");
          parser.parse(buf);
          work();
        };
        const streamErrorHandler = (error) => {
          this.log("streamErrorHandler :: error", error.message);
          if (error.code) {
            this.log("streamErrorHandler :: emitting error");
            this.emit("error", error);
          } else {
            this.noop(error);
          }
        };
        this.log("connect :: pipe stream to writable stream");
        this.stream.pipe(writable);
        this.stream.on("error", streamErrorHandler);
        this.stream.on("close", () => {
          this.log("(%s)stream :: on close", this.options.clientId);
          this._flushVolatile();
          this.log("stream: emit close to MqttClient");
          this.emit("close");
        });
        this.log("connect: sending packet `connect`");
        const connectPacket = {
          cmd: "connect",
          protocolId: this.options.protocolId,
          protocolVersion: this.options.protocolVersion,
          clean: this.options.clean,
          clientId: this.options.clientId,
          keepalive: this.options.keepalive,
          username: this.options.username,
          password: this.options.password,
          properties: this.options.properties
        };
        if (this.options.will) {
          connectPacket.will = Object.assign(Object.assign({}, this.options.will), { payload: (_a = this.options.will) === null || _a === void 0 ? void 0 : _a.payload });
        }
        if (this.topicAliasRecv) {
          if (!connectPacket.properties) {
            connectPacket.properties = {};
          }
          if (this.topicAliasRecv) {
            connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;
          }
        }
        this._writePacket(connectPacket);
        parser.on("error", this.emit.bind(this, "error"));
        if (this.options.properties) {
          if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
            this.end(() => this.emit("error", new Error("Packet has no Authentication Method")));
            return this;
          }
          if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === "object") {
            const authPacket = Object.assign({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
            this._writePacket(authPacket);
          }
        }
        this.stream.setMaxListeners(1e3);
        clearTimeout(this.connackTimer);
        this.connackTimer = setTimeout(() => {
          this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`");
          this.emit("error", new Error("connack timeout"));
          this._cleanUp(true);
        }, this.options.connectTimeout);
        return this;
      }
      publish(topic, message, opts, callback) {
        this.log("publish :: message `%s` to topic `%s`", message, topic);
        const { options } = this;
        if (typeof opts === "function") {
          callback = opts;
          opts = null;
        }
        opts = opts || {};
        const defaultOpts = {
          qos: 0,
          retain: false,
          dup: false
        };
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const { qos, retain, dup, properties, cbStorePut } = opts;
        if (this._checkDisconnecting(callback)) {
          return this;
        }
        const publishProc = () => {
          let messageId = 0;
          if (qos === 1 || qos === 2) {
            messageId = this._nextId();
            if (messageId === null) {
              this.log("No messageId left");
              return false;
            }
          }
          const packet = {
            cmd: "publish",
            topic,
            payload: message,
            qos,
            retain,
            messageId,
            dup
          };
          if (options.protocolVersion === 5) {
            packet.properties = properties;
          }
          this.log("publish :: qos", qos);
          switch (qos) {
            case 1:
            case 2:
              this.outgoing[packet.messageId] = {
                volatile: false,
                cb: callback || this.noop
              };
              this.log("MqttClient:publish: packet cmd: %s", packet.cmd);
              this._sendPacket(packet, void 0, cbStorePut);
              break;
            default:
              this.log("MqttClient:publish: packet cmd: %s", packet.cmd);
              this._sendPacket(packet, callback, cbStorePut);
              break;
          }
          return true;
        };
        if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {
          this._storeProcessingQueue.push({
            invoke: publishProc,
            cbStorePut: opts.cbStorePut,
            callback
          });
        }
        return this;
      }
      publishAsync(topic, message, opts) {
        return new Promise((resolve, reject) => {
          this.publish(topic, message, opts, (err, packet) => {
            if (err) {
              reject(err);
            } else {
              resolve(packet);
            }
          });
        });
      }
      subscribe(topicObject, opts, callback) {
        const version = this.options.protocolVersion;
        if (typeof opts === "function") {
          callback = opts;
        }
        callback = callback || this.noop;
        let resubscribe = false;
        let topicsList = [];
        if (typeof topicObject === "string") {
          topicObject = [topicObject];
          topicsList = topicObject;
        } else if (Array.isArray(topicObject)) {
          topicsList = topicObject;
        } else if (typeof topicObject === "object") {
          resubscribe = topicObject.resubscribe;
          delete topicObject.resubscribe;
          topicsList = Object.keys(topicObject);
        }
        const invalidTopic = validations.validateTopics(topicsList);
        if (invalidTopic !== null) {
          setImmediate2(callback, new Error(`Invalid topic ${invalidTopic}`));
          return this;
        }
        if (this._checkDisconnecting(callback)) {
          this.log("subscribe: discconecting true");
          return this;
        }
        const defaultOpts = {
          qos: 0
        };
        if (version === 5) {
          defaultOpts.nl = false;
          defaultOpts.rap = false;
          defaultOpts.rh = 0;
        }
        opts = Object.assign(Object.assign({}, defaultOpts), opts);
        const properties = opts.properties;
        const subs = [];
        const parseSub = (topic, subOptions) => {
          subOptions = subOptions || opts;
          if (!Object.prototype.hasOwnProperty.call(this._resubscribeTopics, topic) || this._resubscribeTopics[topic].qos < subOptions.qos || resubscribe) {
            const currentOpts = {
              topic,
              qos: subOptions.qos
            };
            if (version === 5) {
              currentOpts.nl = subOptions.nl;
              currentOpts.rap = subOptions.rap;
              currentOpts.rh = subOptions.rh;
              currentOpts.properties = properties;
            }
            this.log("subscribe: pushing topic `%s` and qos `%s` to subs list", currentOpts.topic, currentOpts.qos);
            subs.push(currentOpts);
          }
        };
        if (Array.isArray(topicObject)) {
          topicObject.forEach((topic) => {
            this.log("subscribe: array topic %s", topic);
            parseSub(topic);
          });
        } else {
          Object.keys(topicObject).forEach((topic) => {
            this.log("subscribe: object topic %s, %o", topic, topicObject[topic]);
            parseSub(topic, topicObject[topic]);
          });
        }
        if (!subs.length) {
          callback(null, []);
          return this;
        }
        const subscribeProc = () => {
          const messageId = this._nextId();
          if (messageId === null) {
            this.log("No messageId left");
            return false;
          }
          const packet = {
            cmd: "subscribe",
            subscriptions: subs,
            messageId
          };
          if (properties) {
            packet.properties = properties;
          }
          if (this.options.resubscribe) {
            this.log("subscribe :: resubscribe true");
            const topics = [];
            subs.forEach((sub) => {
              if (this.options.reconnectPeriod > 0) {
                const topic = { qos: sub.qos };
                if (version === 5) {
                  topic.nl = sub.nl || false;
                  topic.rap = sub.rap || false;
                  topic.rh = sub.rh || 0;
                  topic.properties = sub.properties;
                }
                this._resubscribeTopics[sub.topic] = topic;
                topics.push(sub.topic);
              }
            });
            this.messageIdToTopic[packet.messageId] = topics;
          }
          this.outgoing[packet.messageId] = {
            volatile: true,
            cb(err, packet2) {
              if (!err) {
                const { granted } = packet2;
                for (let i = 0; i < granted.length; i += 1) {
                  subs[i].qos = granted[i];
                }
              }
              callback(err, subs, packet2);
            }
          };
          this.log("subscribe :: call _sendPacket");
          this._sendPacket(packet);
          return true;
        };
        if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {
          this._storeProcessingQueue.push({
            invoke: subscribeProc,
            callback
          });
        }
        return this;
      }
      subscribeAsync(topicObject, opts) {
        return new Promise((resolve, reject) => {
          this.subscribe(topicObject, opts, (err, granted) => {
            if (err) {
              reject(err);
            } else {
              resolve(granted);
            }
          });
        });
      }
      unsubscribe(topic, opts, callback) {
        if (typeof topic === "string") {
          topic = [topic];
        }
        if (typeof opts === "function") {
          callback = opts;
        }
        callback = callback || this.noop;
        const invalidTopic = validations.validateTopics(topic);
        if (invalidTopic !== null) {
          setImmediate2(callback, new Error(`Invalid topic ${invalidTopic}`));
          return this;
        }
        if (this._checkDisconnecting(callback)) {
          return this;
        }
        const unsubscribeProc = () => {
          const messageId = this._nextId();
          if (messageId === null) {
            this.log("No messageId left");
            return false;
          }
          const packet = {
            cmd: "unsubscribe",
            messageId,
            unsubscriptions: []
          };
          if (typeof topic === "string") {
            packet.unsubscriptions = [topic];
          } else if (Array.isArray(topic)) {
            packet.unsubscriptions = topic;
          }
          if (this.options.resubscribe) {
            packet.unsubscriptions.forEach((topic2) => {
              delete this._resubscribeTopics[topic2];
            });
          }
          if (typeof opts === "object" && opts.properties) {
            packet.properties = opts.properties;
          }
          this.outgoing[packet.messageId] = {
            volatile: true,
            cb: callback
          };
          this.log("unsubscribe: call _sendPacket");
          this._sendPacket(packet);
          return true;
        };
        if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {
          this._storeProcessingQueue.push({
            invoke: unsubscribeProc,
            callback
          });
        }
        return this;
      }
      unsubscribeAsync(topic, opts) {
        return new Promise((resolve, reject) => {
          this.unsubscribe(topic, opts, (err, packet) => {
            if (err) {
              reject(err);
            } else {
              resolve(packet);
            }
          });
        });
      }
      end(force, opts, cb) {
        this.log("end :: (%s)", this.options.clientId);
        if (force == null || typeof force !== "boolean") {
          cb = cb || opts;
          opts = force;
          force = false;
        }
        if (typeof opts !== "object") {
          cb = cb || opts;
          opts = null;
        }
        this.log("end :: cb? %s", !!cb);
        if (!cb || typeof cb !== "function") {
          cb = this.noop;
        }
        const closeStores = () => {
          this.log("end :: closeStores: closing incoming and outgoing stores");
          this.disconnected = true;
          this.incomingStore.close((e1) => {
            this.outgoingStore.close((e2) => {
              this.log("end :: closeStores: emitting end");
              this.emit("end");
              if (cb) {
                const err = e1 || e2;
                this.log("end :: closeStores: invoking callback with args");
                cb(err);
              }
            });
          });
          if (this._deferredReconnect) {
            this._deferredReconnect();
          } else if (this.options.reconnectPeriod === 0 || this.options.manualConnect) {
            this.disconnecting = false;
          }
        };
        const finish = () => {
          this.log("end :: (%s) :: finish :: calling _cleanUp with force %s", this.options.clientId, force);
          this._cleanUp(force, () => {
            this.log("end :: finish :: calling process.nextTick on closeStores");
            (0, shared_1.nextTick)(closeStores);
          }, opts);
        };
        if (this.disconnecting) {
          cb();
          return this;
        }
        this._clearReconnect();
        this.disconnecting = true;
        if (!force && Object.keys(this.outgoing).length > 0) {
          this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty", this.options.clientId);
          this.once("outgoingEmpty", setTimeout.bind(null, finish, 10));
        } else {
          this.log("end :: (%s) :: immediately calling finish", this.options.clientId);
          finish();
        }
        return this;
      }
      endAsync(force, opts) {
        return new Promise((resolve, reject) => {
          this.end(force, opts, (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      }
      removeOutgoingMessage(messageId) {
        if (this.outgoing[messageId]) {
          const { cb } = this.outgoing[messageId];
          this._removeOutgoingAndStoreMessage(messageId, () => {
            cb(new Error("Message removed"));
          });
        }
        return this;
      }
      reconnect(opts) {
        this.log("client reconnect");
        const f = () => {
          if (opts) {
            this.options.incomingStore = opts.incomingStore;
            this.options.outgoingStore = opts.outgoingStore;
          } else {
            this.options.incomingStore = null;
            this.options.outgoingStore = null;
          }
          this.incomingStore = this.options.incomingStore || new store_1.default();
          this.outgoingStore = this.options.outgoingStore || new store_1.default();
          this.disconnecting = false;
          this.disconnected = false;
          this._deferredReconnect = null;
          this._reconnect();
        };
        if (this.disconnecting && !this.disconnected) {
          this._deferredReconnect = f;
        } else {
          f();
        }
        return this;
      }
      _flushVolatile() {
        if (this.outgoing) {
          this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function");
          Object.keys(this.outgoing).forEach((messageId) => {
            if (this.outgoing[messageId].volatile && typeof this.outgoing[messageId].cb === "function") {
              this.outgoing[messageId].cb(new Error("Connection closed"));
              delete this.outgoing[messageId];
            }
          });
        }
      }
      _flush() {
        if (this.outgoing) {
          this.log("_flush: queue exists? %b", !!this.outgoing);
          Object.keys(this.outgoing).forEach((messageId) => {
            if (typeof this.outgoing[messageId].cb === "function") {
              this.outgoing[messageId].cb(new Error("Connection closed"));
              delete this.outgoing[messageId];
            }
          });
        }
      }
      _removeTopicAliasAndRecoverTopicName(packet) {
        let alias;
        if (packet.properties) {
          alias = packet.properties.topicAlias;
        }
        let topic = packet.topic.toString();
        this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o", alias, topic);
        if (topic.length === 0) {
          if (typeof alias === "undefined") {
            return new Error("Unregistered Topic Alias");
          }
          topic = this.topicAliasSend.getTopicByAlias(alias);
          if (typeof topic === "undefined") {
            return new Error("Unregistered Topic Alias");
          }
          packet.topic = topic;
        }
        if (alias) {
          delete packet.properties.topicAlias;
        }
      }
      _checkDisconnecting(callback) {
        if (this.disconnecting) {
          if (callback && callback !== this.noop) {
            callback(new Error("client disconnecting"));
          } else {
            this.emit("error", new Error("client disconnecting"));
          }
        }
        return this.disconnecting;
      }
      _reconnect() {
        this.log("_reconnect: emitting reconnect to client");
        this.emit("reconnect");
        if (this.connected) {
          this.end(() => {
            this.connect();
          });
          this.log("client already connected. disconnecting first.");
        } else {
          this.log("_reconnect: calling connect");
          this.connect();
        }
      }
      _setupReconnect() {
        if (!this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0) {
          if (!this.reconnecting) {
            this.log("_setupReconnect :: emit `offline` state");
            this.emit("offline");
            this.log("_setupReconnect :: set `reconnecting` to `true`");
            this.reconnecting = true;
          }
          this.log("_setupReconnect :: setting reconnectTimer for %d ms", this.options.reconnectPeriod);
          this.reconnectTimer = setInterval(() => {
            this.log("reconnectTimer :: reconnect triggered!");
            this._reconnect();
          }, this.options.reconnectPeriod);
        } else {
          this.log("_setupReconnect :: doing nothing...");
        }
      }
      _clearReconnect() {
        this.log("_clearReconnect : clearing reconnect timer");
        if (this.reconnectTimer) {
          clearInterval(this.reconnectTimer);
          this.reconnectTimer = null;
        }
      }
      _cleanUp(forced, done, opts = {}) {
        if (done) {
          this.log("_cleanUp :: done callback provided for on stream close");
          this.stream.on("close", done);
        }
        this.log("_cleanUp :: forced? %s", forced);
        if (forced) {
          if (this.options.reconnectPeriod === 0 && this.options.clean) {
            this._flush();
          }
          this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
          this.stream.destroy();
        } else {
          const packet = Object.assign({ cmd: "disconnect" }, opts);
          this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId);
          this._sendPacket(packet, () => {
            this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
            setImmediate2(() => {
              this.stream.end(() => {
                this.log("_cleanUp :: (%s) :: stream destroyed", this.options.clientId);
              });
            });
          });
        }
        if (!this.disconnecting && !this.reconnecting) {
          this.log("_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect.");
          this._clearReconnect();
          this._setupReconnect();
        }
        this._destroyKeepaliveManager();
        if (done && !this.connected) {
          this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId);
          this.stream.removeListener("close", done);
          done();
        }
      }
      _storeAndSend(packet, cb, cbStorePut) {
        this.log("storeAndSend :: store packet with cmd %s to outgoingStore", packet.cmd);
        let storePacket = packet;
        let err;
        if (storePacket.cmd === "publish") {
          storePacket = (0, default_1.default)(packet);
          err = this._removeTopicAliasAndRecoverTopicName(storePacket);
          if (err) {
            return cb && cb(err);
          }
        }
        this.outgoingStore.put(storePacket, (err2) => {
          if (err2) {
            return cb && cb(err2);
          }
          cbStorePut();
          this._writePacket(packet, cb);
        });
      }
      _applyTopicAlias(packet) {
        if (this.options.protocolVersion === 5) {
          if (packet.cmd === "publish") {
            let alias;
            if (packet.properties) {
              alias = packet.properties.topicAlias;
            }
            const topic = packet.topic.toString();
            if (this.topicAliasSend) {
              if (alias) {
                if (topic.length !== 0) {
                  this.log("applyTopicAlias :: register topic: %s - alias: %d", topic, alias);
                  if (!this.topicAliasSend.put(topic, alias)) {
                    this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                    return new Error("Sending Topic Alias out of range");
                  }
                }
              } else if (topic.length !== 0) {
                if (this.options.autoAssignTopicAlias) {
                  alias = this.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                    this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", topic, alias);
                  } else {
                    alias = this.topicAliasSend.getLruAlias();
                    this.topicAliasSend.put(topic, alias);
                    packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                    this.log("applyTopicAlias :: auto assign topic: %s - alias: %d", topic, alias);
                  }
                } else if (this.options.autoUseTopicAlias) {
                  alias = this.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                    this.log("applyTopicAlias :: auto use topic: %s - alias: %d", topic, alias);
                  }
                }
              }
            } else if (alias) {
              this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
              return new Error("Sending Topic Alias out of range");
            }
          }
        }
      }
      _noop(err) {
        this.log("noop ::", err);
      }
      _writePacket(packet, cb) {
        this.log("_writePacket :: packet: %O", packet);
        this.log("_writePacket :: emitting `packetsend`");
        this.emit("packetsend", packet);
        this.log("_writePacket :: writing to stream");
        const result = mqtt_packet_1.default.writeToStream(packet, this.stream, this.options);
        this.log("_writePacket :: writeToStream result %s", result);
        if (!result && cb && cb !== this.noop) {
          this.log("_writePacket :: handle events on `drain` once through callback.");
          this.stream.once("drain", cb);
        } else if (cb) {
          this.log("_writePacket :: invoking cb");
          cb();
        }
      }
      _sendPacket(packet, cb, cbStorePut, noStore) {
        this.log("_sendPacket :: (%s) ::  start", this.options.clientId);
        cbStorePut = cbStorePut || this.noop;
        cb = cb || this.noop;
        const err = this._applyTopicAlias(packet);
        if (err) {
          cb(err);
          return;
        }
        if (!this.connected) {
          if (packet.cmd === "auth") {
            this._writePacket(packet, cb);
            return;
          }
          this.log("_sendPacket :: client not connected. Storing packet offline.");
          this._storePacket(packet, cb, cbStorePut);
          return;
        }
        if (noStore) {
          this._writePacket(packet, cb);
          return;
        }
        switch (packet.cmd) {
          case "publish":
            break;
          case "pubrel":
            this._storeAndSend(packet, cb, cbStorePut);
            return;
          default:
            this._writePacket(packet, cb);
            return;
        }
        switch (packet.qos) {
          case 2:
          case 1:
            this._storeAndSend(packet, cb, cbStorePut);
            break;
          case 0:
          default:
            this._writePacket(packet, cb);
            break;
        }
        this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
      }
      _storePacket(packet, cb, cbStorePut) {
        this.log("_storePacket :: packet: %o", packet);
        this.log("_storePacket :: cb? %s", !!cb);
        cbStorePut = cbStorePut || this.noop;
        let storePacket = packet;
        if (storePacket.cmd === "publish") {
          storePacket = (0, default_1.default)(packet);
          const err = this._removeTopicAliasAndRecoverTopicName(storePacket);
          if (err) {
            return cb && cb(err);
          }
        }
        const qos = storePacket.qos || 0;
        if (qos === 0 && this.queueQoSZero || storePacket.cmd !== "publish") {
          this.queue.push({ packet: storePacket, cb });
        } else if (qos > 0) {
          cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;
          this.outgoingStore.put(storePacket, (err) => {
            if (err) {
              return cb && cb(err);
            }
            cbStorePut();
          });
        } else if (cb) {
          cb(new Error("No connection to broker"));
        }
      }
      _setupKeepaliveManager() {
        this.log("_setupKeepaliveManager :: keepalive %d (seconds)", this.options.keepalive);
        if (!this.keepaliveManager && this.options.keepalive) {
          this.keepaliveManager = new KeepaliveManager_1.default(this, this.options.timerVariant);
        }
      }
      _destroyKeepaliveManager() {
        if (this.keepaliveManager) {
          this.log("_destroyKeepaliveManager :: destroying keepalive manager");
          this.keepaliveManager.destroy();
          this.keepaliveManager = null;
        }
      }
      reschedulePing(force = false) {
        if (this.keepaliveManager && this.options.keepalive && (force || this.options.reschedulePings)) {
          this._reschedulePing();
        }
      }
      _reschedulePing() {
        this.log("_reschedulePing :: rescheduling ping");
        this.keepaliveManager.reschedule();
      }
      sendPing() {
        this.log("_sendPing :: sending pingreq");
        this._sendPacket({ cmd: "pingreq" });
      }
      onKeepaliveTimeout() {
        this.emit("error", new Error("Keepalive timeout"));
        this.log("onKeepaliveTimeout :: calling _cleanUp with force true");
        this._cleanUp(true);
      }
      _resubscribe() {
        this.log("_resubscribe");
        const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
        if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {
          if (this.options.resubscribe) {
            if (this.options.protocolVersion === 5) {
              this.log("_resubscribe: protocolVersion 5");
              for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
                const resubscribeTopic = {};
                resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
                resubscribeTopic.resubscribe = true;
                this.subscribe(resubscribeTopic, {
                  properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties
                });
              }
            } else {
              this._resubscribeTopics.resubscribe = true;
              this.subscribe(this._resubscribeTopics);
            }
          } else {
            this._resubscribeTopics = {};
          }
        }
        this._firstConnection = false;
      }
      _onConnect(packet) {
        if (this.disconnected) {
          this.emit("connect", packet);
          return;
        }
        this.connackPacket = packet;
        this.messageIdProvider.clear();
        this._setupKeepaliveManager();
        this.connected = true;
        const startStreamProcess = () => {
          let outStore = this.outgoingStore.createStream();
          const remove = () => {
            outStore.destroy();
            outStore = null;
            this._flushStoreProcessingQueue();
            clearStoreProcessing();
          };
          const clearStoreProcessing = () => {
            this._storeProcessing = false;
            this._packetIdsDuringStoreProcessing = {};
          };
          this.once("close", remove);
          outStore.on("error", (err) => {
            clearStoreProcessing();
            this._flushStoreProcessingQueue();
            this.removeListener("close", remove);
            this.emit("error", err);
          });
          const storeDeliver = () => {
            if (!outStore) {
              return;
            }
            const packet2 = outStore.read(1);
            let cb;
            if (!packet2) {
              outStore.once("readable", storeDeliver);
              return;
            }
            this._storeProcessing = true;
            if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {
              storeDeliver();
              return;
            }
            if (!this.disconnecting && !this.reconnectTimer) {
              cb = this.outgoing[packet2.messageId] ? this.outgoing[packet2.messageId].cb : null;
              this.outgoing[packet2.messageId] = {
                volatile: false,
                cb(err, status) {
                  if (cb) {
                    cb(err, status);
                  }
                  storeDeliver();
                }
              };
              this._packetIdsDuringStoreProcessing[packet2.messageId] = true;
              if (this.messageIdProvider.register(packet2.messageId)) {
                this._sendPacket(packet2, void 0, void 0, true);
              } else {
                this.log("messageId: %d has already used.", packet2.messageId);
              }
            } else if (outStore.destroy) {
              outStore.destroy();
            }
          };
          outStore.on("end", () => {
            let allProcessed = true;
            for (const id in this._packetIdsDuringStoreProcessing) {
              if (!this._packetIdsDuringStoreProcessing[id]) {
                allProcessed = false;
                break;
              }
            }
            this.removeListener("close", remove);
            if (allProcessed) {
              clearStoreProcessing();
              this._invokeAllStoreProcessingQueue();
              this.emit("connect", packet);
            } else {
              startStreamProcess();
            }
          });
          storeDeliver();
        };
        startStreamProcess();
      }
      _invokeStoreProcessingQueue() {
        if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
          const f = this._storeProcessingQueue[0];
          if (f && f.invoke()) {
            this._storeProcessingQueue.shift();
            return true;
          }
        }
        return false;
      }
      _invokeAllStoreProcessingQueue() {
        while (this._invokeStoreProcessingQueue()) {
        }
      }
      _flushStoreProcessingQueue() {
        for (const f of this._storeProcessingQueue) {
          if (f.cbStorePut)
            f.cbStorePut(new Error("Connection closed"));
          if (f.callback)
            f.callback(new Error("Connection closed"));
        }
        this._storeProcessingQueue.splice(0);
      }
      _removeOutgoingAndStoreMessage(messageId, cb) {
        delete this.outgoing[messageId];
        this.outgoingStore.del({ messageId }, (err, packet) => {
          cb(err, packet);
          this.messageIdProvider.deallocate(messageId);
          this._invokeStoreProcessingQueue();
        });
      }
    };
    MqttClient.VERSION = shared_1.MQTTJS_VERSION;
    exports.default = MqttClient;
  }
});

// node_modules/mqtt/build/lib/unique-message-id-provider.js
var require_unique_message_id_provider = __commonJS({
  "node_modules/mqtt/build/lib/unique-message-id-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var number_allocator_1 = require_number_allocator2();
    var UniqueMessageIdProvider = class {
      constructor() {
        this.numberAllocator = new number_allocator_1.NumberAllocator(1, 65535);
      }
      allocate() {
        this.lastId = this.numberAllocator.alloc();
        return this.lastId;
      }
      getLastAllocated() {
        return this.lastId;
      }
      register(messageId) {
        return this.numberAllocator.use(messageId);
      }
      deallocate(messageId) {
        this.numberAllocator.free(messageId);
      }
      clear() {
        this.numberAllocator.clear();
      }
    };
    exports.default = UniqueMessageIdProvider;
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob)
      BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants2();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored)
          cb();
      }
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
            cb(error);
            return;
          }
        } else {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
          cb(error);
          return;
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          this.haveLength(cb);
      }
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO)
            this.startLoop(cb);
        });
      }
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
              cb(error);
              return;
            }
            const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants2();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class {
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while the blob was being read");
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function")
        cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function")
          callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout)
          socket.setTimeout(0);
        if (socket.setNoDelay)
          socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong)
        websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED)
        return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream2();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/mqtt/build/lib/BufferedDuplex.js
var require_BufferedDuplex = __commonJS({
  "node_modules/mqtt/build/lib/BufferedDuplex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedDuplex = exports.writev = void 0;
    var readable_stream_1 = require_ours();
    var buffer_1 = require("buffer");
    function writev(chunks, cb) {
      const buffers = new Array(chunks.length);
      for (let i = 0; i < chunks.length; i++) {
        if (typeof chunks[i].chunk === "string") {
          buffers[i] = buffer_1.Buffer.from(chunks[i].chunk, "utf8");
        } else {
          buffers[i] = chunks[i].chunk;
        }
      }
      this._write(buffer_1.Buffer.concat(buffers), "binary", cb);
    }
    exports.writev = writev;
    var BufferedDuplex = class extends readable_stream_1.Duplex {
      constructor(opts, proxy, socket) {
        super({
          objectMode: true
        });
        this.proxy = proxy;
        this.socket = socket;
        this.writeQueue = [];
        if (!opts.objectMode) {
          this._writev = writev.bind(this);
        }
        this.isSocketOpen = false;
        this.proxy.on("data", (chunk) => {
          if (!this.destroyed) {
            this.push(chunk);
          }
        });
      }
      _read(size) {
        this.proxy.read(size);
      }
      _write(chunk, encoding, cb) {
        if (!this.isSocketOpen) {
          this.writeQueue.push({ chunk, encoding, cb });
        } else {
          this.writeToProxy(chunk, encoding, cb);
        }
      }
      _final(callback) {
        this.writeQueue = [];
        this.proxy.end(callback);
      }
      _destroy(err, callback) {
        this.writeQueue = [];
        this.proxy.destroy();
        callback(err);
      }
      socketReady() {
        this.emit("connect");
        this.isSocketOpen = true;
        this.processWriteQueue();
      }
      writeToProxy(chunk, encoding, cb) {
        if (this.proxy.write(chunk, encoding) === false) {
          this.proxy.once("drain", cb);
        } else {
          cb();
        }
      }
      processWriteQueue() {
        while (this.writeQueue.length > 0) {
          const { chunk, encoding, cb } = this.writeQueue.shift();
          this.writeToProxy(chunk, encoding, cb);
        }
      }
    };
    exports.BufferedDuplex = BufferedDuplex;
  }
});

// node_modules/mqtt/build/lib/connect/ws.js
var require_ws2 = __commonJS({
  "node_modules/mqtt/build/lib/connect/ws.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.streamBuilder = exports.browserStreamBuilder = void 0;
    var buffer_1 = require("buffer");
    var ws_1 = __importDefault(require_ws());
    var debug_1 = __importDefault(require_src2());
    var readable_stream_1 = require_ours();
    var is_browser_1 = __importDefault(require_is_browser());
    var BufferedDuplex_1 = require_BufferedDuplex();
    var debug = (0, debug_1.default)("mqttjs:ws");
    var WSS_OPTIONS = [
      "rejectUnauthorized",
      "ca",
      "cert",
      "key",
      "pfx",
      "passphrase"
    ];
    function buildUrl(opts, client) {
      let url = `${opts.protocol}://${opts.hostname}:${opts.port}${opts.path}`;
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function setDefaultOpts(opts) {
      const options = opts;
      if (!opts.port) {
        if (opts.protocol === "wss") {
          options.port = 443;
        } else {
          options.port = 80;
        }
      }
      if (!opts.path) {
        options.path = "/";
      }
      if (!opts.wsOptions) {
        options.wsOptions = {};
      }
      if (!is_browser_1.default && !opts.forceNativeWebSocket && opts.protocol === "wss") {
        WSS_OPTIONS.forEach((prop) => {
          if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
            options.wsOptions[prop] = opts[prop];
          }
        });
      }
      return options;
    }
    function setDefaultBrowserOpts(opts) {
      const options = setDefaultOpts(opts);
      if (!options.hostname) {
        options.hostname = options.host;
      }
      if (!options.hostname) {
        if (typeof document === "undefined") {
          throw new Error("Could not determine host. Specify host manually.");
        }
        const parsed = new URL(document.URL);
        options.hostname = parsed.hostname;
        if (!options.port) {
          options.port = Number(parsed.port);
        }
      }
      if (options.objectMode === void 0) {
        options.objectMode = !(options.binary === true || options.binary === void 0);
      }
      return options;
    }
    function createWebSocket(client, url, opts) {
      debug("createWebSocket");
      debug(`protocol: ${opts.protocolId} ${opts.protocolVersion}`);
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      debug(`creating new Websocket for url: ${url} and protocol: ${websocketSubProtocol}`);
      let socket;
      if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
      } else {
        socket = new ws_1.default(url, [websocketSubProtocol], opts.wsOptions);
      }
      return socket;
    }
    function createBrowserWebSocket(client, opts) {
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      const url = buildUrl(opts, client);
      let socket;
      if (opts.createWebsocket) {
        socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
      } else {
        socket = new WebSocket(url, [websocketSubProtocol]);
      }
      socket.binaryType = "arraybuffer";
      return socket;
    }
    var streamBuilder = (client, opts) => {
      debug("streamBuilder");
      const options = setDefaultOpts(opts);
      options.hostname = options.hostname || options.host || "localhost";
      const url = buildUrl(options, client);
      const socket = createWebSocket(client, url, options);
      const webSocketStream = ws_1.default.createWebSocketStream(socket, options.wsOptions);
      webSocketStream["url"] = url;
      socket.on("close", () => {
        webSocketStream.destroy();
      });
      return webSocketStream;
    };
    exports.streamBuilder = streamBuilder;
    var browserStreamBuilder = (client, opts) => {
      debug("browserStreamBuilder");
      let stream;
      const options = setDefaultBrowserOpts(opts);
      const bufferSize = options.browserBufferSize || 1024 * 512;
      const bufferTimeout = opts.browserBufferTimeout || 1e3;
      const coerceToBuffer = !opts.objectMode;
      const socket = createBrowserWebSocket(client, opts);
      const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
      if (!opts.objectMode) {
        proxy._writev = BufferedDuplex_1.writev.bind(proxy);
      }
      proxy.on("close", () => {
        socket.close();
      });
      const eventListenerSupport = typeof socket.addEventListener !== "undefined";
      if (socket.readyState === socket.OPEN) {
        stream = proxy;
        stream.socket = socket;
      } else {
        stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, socket);
        if (eventListenerSupport) {
          socket.addEventListener("open", onOpen);
        } else {
          socket.onopen = onOpen;
        }
      }
      if (eventListenerSupport) {
        socket.addEventListener("close", onClose);
        socket.addEventListener("error", onError);
        socket.addEventListener("message", onMessage);
      } else {
        socket.onclose = onClose;
        socket.onerror = onError;
        socket.onmessage = onMessage;
      }
      function buildProxy(pOptions, socketWrite, socketEnd) {
        const _proxy = new readable_stream_1.Transform({
          objectMode: pOptions.objectMode
        });
        _proxy._write = socketWrite;
        _proxy._flush = socketEnd;
        return _proxy;
      }
      function onOpen() {
        debug("WebSocket onOpen");
        if (stream instanceof BufferedDuplex_1.BufferedDuplex) {
          stream.socketReady();
        }
      }
      function onClose(event) {
        debug("WebSocket onClose", event);
        stream.end();
        stream.destroy();
      }
      function onError(err) {
        debug("WebSocket onError", err);
        const error = new Error("WebSocket error");
        error["event"] = err;
        stream.destroy(error);
      }
      async function onMessage(event) {
        let { data } = event;
        if (data instanceof ArrayBuffer)
          data = buffer_1.Buffer.from(data);
        else if (data instanceof Blob)
          data = buffer_1.Buffer.from(await new Response(data).arrayBuffer());
        else
          data = buffer_1.Buffer.from(data, "utf8");
        if (proxy && !proxy.destroyed) {
          proxy.push(data);
        }
      }
      function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
          setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
          return;
        }
        if (coerceToBuffer && typeof chunk === "string") {
          chunk = buffer_1.Buffer.from(chunk, "utf8");
        }
        try {
          socket.send(chunk);
        } catch (err) {
          return next(err);
        }
        next();
      }
      function socketEndBrowser(done) {
        socket.close();
        done();
      }
      return stream;
    };
    exports.browserStreamBuilder = browserStreamBuilder;
  }
});

// node_modules/mqtt/build/lib/connect/tcp.js
var require_tcp = __commonJS({
  "node_modules/mqtt/build/lib/connect/tcp.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var debug_1 = __importDefault(require_src2());
    var debug = (0, debug_1.default)("mqttjs:tcp");
    var buildStream = (client, opts) => {
      opts.port = opts.port || 1883;
      opts.hostname = opts.hostname || opts.host || "localhost";
      const { port, path } = opts;
      const host = opts.hostname;
      debug("port %d and host %s", port, host);
      return net_1.default.createConnection({ port, host, path });
    };
    exports.default = buildStream;
  }
});

// node_modules/mqtt/build/lib/connect/tls.js
var require_tls = __commonJS({
  "node_modules/mqtt/build/lib/connect/tls.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tls_1 = __importDefault(require("tls"));
    var net_1 = __importDefault(require("net"));
    var debug_1 = __importDefault(require_src2());
    var debug = (0, debug_1.default)("mqttjs:tls");
    var buildStream = (client, opts) => {
      opts.port = opts.port || 8883;
      opts.host = opts.hostname || opts.host || "localhost";
      if (net_1.default.isIP(opts.host) === 0) {
        opts.servername = opts.host;
      }
      opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
      delete opts.path;
      debug("port %d host %s rejectUnauthorized %b", opts.port, opts.host, opts.rejectUnauthorized);
      const connection = tls_1.default.connect(opts);
      connection.on("secureConnect", () => {
        if (opts.rejectUnauthorized && !connection.authorized) {
          connection.emit("error", new Error("TLS not authorized"));
        } else {
          connection.removeListener("error", handleTLSerrors);
        }
      });
      function handleTLSerrors(err) {
        if (opts.rejectUnauthorized) {
          client.emit("error", err);
        }
        connection.end();
      }
      connection.on("error", handleTLSerrors);
      return connection;
    };
    exports.default = buildStream;
  }
});

// node_modules/mqtt/build/lib/connect/wx.js
var require_wx = __commonJS({
  "node_modules/mqtt/build/lib/connect/wx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var readable_stream_1 = require_ours();
    var BufferedDuplex_1 = require_BufferedDuplex();
    var socketTask;
    var proxy;
    var stream;
    function buildProxy() {
      const _proxy = new readable_stream_1.Transform();
      _proxy._write = (chunk, encoding, next) => {
        socketTask.send({
          data: chunk.buffer,
          success() {
            next();
          },
          fail(errMsg) {
            next(new Error(errMsg));
          }
        });
      };
      _proxy._flush = (done) => {
        socketTask.close({
          success() {
            done();
          }
        });
      };
      return _proxy;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "wxs" ? "wss" : "ws";
      let url = `${protocol}://${opts.hostname}${opts.path}`;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      socketTask.onOpen(() => {
        stream.socketReady();
      });
      socketTask.onMessage((res) => {
        let { data } = res;
        if (data instanceof ArrayBuffer)
          data = buffer_1.Buffer.from(data);
        else
          data = buffer_1.Buffer.from(data, "utf8");
        proxy.push(data);
      });
      socketTask.onClose(() => {
        stream.emit("close");
        stream.end();
        stream.destroy();
      });
      socketTask.onError((error) => {
        const err = new Error(error.errMsg);
        stream.destroy(err);
      });
    }
    var buildStream = (client, opts) => {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      socketTask = wx.connectSocket({
        url,
        protocols: [websocketSubProtocol]
      });
      proxy = buildProxy();
      stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, socketTask);
      stream._destroy = (err, cb) => {
        socketTask.close({
          success() {
            if (cb)
              cb(err);
          }
        });
      };
      const destroyRef = stream.destroy;
      stream.destroy = (err, cb) => {
        stream.destroy = destroyRef;
        setTimeout(() => {
          socketTask.close({
            fail() {
              stream._destroy(err, cb);
            }
          });
        }, 0);
        return stream;
      };
      bindEventHandler();
      return stream;
    };
    exports.default = buildStream;
  }
});

// node_modules/mqtt/build/lib/connect/ali.js
var require_ali = __commonJS({
  "node_modules/mqtt/build/lib/connect/ali.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var readable_stream_1 = require_ours();
    var BufferedDuplex_1 = require_BufferedDuplex();
    var my;
    var proxy;
    var stream;
    var isInitialized = false;
    function buildProxy() {
      const _proxy = new readable_stream_1.Transform();
      _proxy._write = (chunk, encoding, next) => {
        my.sendSocketMessage({
          data: chunk.buffer,
          success() {
            next();
          },
          fail() {
            next(new Error());
          }
        });
      };
      _proxy._flush = (done) => {
        my.closeSocket({
          success() {
            done();
          }
        });
      };
      return _proxy;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "alis" ? "wss" : "ws";
      let url = `${protocol}://${opts.hostname}${opts.path}`;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      if (isInitialized)
        return;
      isInitialized = true;
      my.onSocketOpen(() => {
        stream.socketReady();
      });
      my.onSocketMessage((res) => {
        if (typeof res.data === "string") {
          const buffer = buffer_1.Buffer.from(res.data, "base64");
          proxy.push(buffer);
        } else {
          const reader = new FileReader();
          reader.addEventListener("load", () => {
            let data = reader.result;
            if (data instanceof ArrayBuffer)
              data = buffer_1.Buffer.from(data);
            else
              data = buffer_1.Buffer.from(data, "utf8");
            proxy.push(data);
          });
          reader.readAsArrayBuffer(res.data);
        }
      });
      my.onSocketClose(() => {
        stream.end();
        stream.destroy();
      });
      my.onSocketError((err) => {
        stream.destroy(err);
      });
    }
    var buildStream = (client, opts) => {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      my = opts.my;
      my.connectSocket({
        url,
        protocols: websocketSubProtocol
      });
      proxy = buildProxy();
      stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, my);
      bindEventHandler();
      return stream;
    };
    exports.default = buildStream;
  }
});

// node_modules/mqtt/build/lib/connect/index.js
var require_connect = __commonJS({
  "node_modules/mqtt/build/lib/connect/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectAsync = void 0;
    var debug_1 = __importDefault(require_src2());
    var url_1 = __importDefault(require("url"));
    var client_1 = __importDefault(require_client());
    var is_browser_1 = __importDefault(require_is_browser());
    if (typeof (process === null || process === void 0 ? void 0 : process.nextTick) !== "function") {
      process.nextTick = setImmediate;
    }
    var debug = (0, debug_1.default)("mqttjs");
    var protocols = null;
    function parseAuthOptions(opts) {
      let matches;
      if (opts.auth) {
        matches = opts.auth.match(/^(.+):(.+)$/);
        if (matches) {
          opts.username = matches[1];
          opts.password = matches[2];
        } else {
          opts.username = opts.auth;
        }
      }
    }
    function connect(brokerUrl2, opts) {
      var _a, _b, _c, _d;
      debug("connecting to an MQTT broker...");
      if (typeof brokerUrl2 === "object" && !opts) {
        opts = brokerUrl2;
        brokerUrl2 = "";
      }
      opts = opts || {};
      if (brokerUrl2 && typeof brokerUrl2 === "string") {
        const parsedUrl = url_1.default.parse(brokerUrl2, true);
        const parsedOptions = {};
        if (parsedUrl.port != null) {
          parsedOptions.port = Number(parsedUrl.port);
        }
        parsedOptions.host = parsedUrl.hostname;
        parsedOptions.query = parsedUrl.query;
        parsedOptions.auth = parsedUrl.auth;
        parsedOptions.protocol = parsedUrl.protocol;
        parsedOptions.path = parsedUrl.path;
        parsedOptions.protocol = (_a = parsedOptions.protocol) === null || _a === void 0 ? void 0 : _a.replace(/:$/, "");
        opts = Object.assign(Object.assign({}, parsedOptions), opts);
        if (!opts.protocol) {
          throw new Error("Missing protocol");
        }
      }
      opts.unixSocket = opts.unixSocket || ((_b = opts.protocol) === null || _b === void 0 ? void 0 : _b.includes("+unix"));
      if (opts.unixSocket) {
        opts.protocol = opts.protocol.replace("+unix", "");
      } else if (!((_c = opts.protocol) === null || _c === void 0 ? void 0 : _c.startsWith("ws")) && !((_d = opts.protocol) === null || _d === void 0 ? void 0 : _d.startsWith("wx"))) {
        delete opts.path;
      }
      parseAuthOptions(opts);
      if (opts.query && typeof opts.query.clientId === "string") {
        opts.clientId = opts.query.clientId;
      }
      if (opts.cert && opts.key) {
        if (opts.protocol) {
          if (["mqtts", "wss", "wxs", "alis"].indexOf(opts.protocol) === -1) {
            switch (opts.protocol) {
              case "mqtt":
                opts.protocol = "mqtts";
                break;
              case "ws":
                opts.protocol = "wss";
                break;
              case "wx":
                opts.protocol = "wxs";
                break;
              case "ali":
                opts.protocol = "alis";
                break;
              default:
                throw new Error(`Unknown protocol for secure connection: "${opts.protocol}"!`);
            }
          }
        } else {
          throw new Error("Missing secure protocol key");
        }
      }
      if (!protocols) {
        protocols = {};
        if (!is_browser_1.default && !opts.forceNativeWebSocket) {
          protocols.ws = require_ws2().streamBuilder;
          protocols.wss = require_ws2().streamBuilder;
          protocols.mqtt = require_tcp().default;
          protocols.tcp = require_tcp().default;
          protocols.ssl = require_tls().default;
          protocols.tls = protocols.ssl;
          protocols.mqtts = require_tls().default;
        } else {
          protocols.ws = require_ws2().browserStreamBuilder;
          protocols.wss = require_ws2().browserStreamBuilder;
          protocols.wx = require_wx().default;
          protocols.wxs = require_wx().default;
          protocols.ali = require_ali().default;
          protocols.alis = require_ali().default;
        }
      }
      if (!protocols[opts.protocol]) {
        const isSecure = ["mqtts", "wss"].indexOf(opts.protocol) !== -1;
        opts.protocol = [
          "mqtt",
          "mqtts",
          "ws",
          "wss",
          "wx",
          "wxs",
          "ali",
          "alis"
        ].filter((key, index) => {
          if (isSecure && index % 2 === 0) {
            return false;
          }
          return typeof protocols[key] === "function";
        })[0];
      }
      if (opts.clean === false && !opts.clientId) {
        throw new Error("Missing clientId for unclean clients");
      }
      if (opts.protocol) {
        opts.defaultProtocol = opts.protocol;
      }
      function wrapper(client2) {
        if (opts.servers) {
          if (!client2._reconnectCount || client2._reconnectCount === opts.servers.length) {
            client2._reconnectCount = 0;
          }
          opts.host = opts.servers[client2._reconnectCount].host;
          opts.port = opts.servers[client2._reconnectCount].port;
          opts.protocol = !opts.servers[client2._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client2._reconnectCount].protocol;
          opts.hostname = opts.host;
          client2._reconnectCount++;
        }
        debug("calling streambuilder for", opts.protocol);
        return protocols[opts.protocol](client2, opts);
      }
      const client = new client_1.default(wrapper, opts);
      client.on("error", () => {
      });
      return client;
    }
    function connectAsync(brokerUrl2, opts, allowRetries = true) {
      return new Promise((resolve, reject) => {
        const client = connect(brokerUrl2, opts);
        const promiseResolutionListeners = {
          connect: (connack) => {
            removePromiseResolutionListeners();
            resolve(client);
          },
          end: () => {
            removePromiseResolutionListeners();
            resolve(client);
          },
          error: (err) => {
            removePromiseResolutionListeners();
            client.end();
            reject(err);
          }
        };
        if (allowRetries === false) {
          promiseResolutionListeners.close = () => {
            promiseResolutionListeners.error(new Error("Couldn't connect to server"));
          };
        }
        function removePromiseResolutionListeners() {
          Object.keys(promiseResolutionListeners).forEach((eventName) => {
            client.off(eventName, promiseResolutionListeners[eventName]);
          });
        }
        Object.keys(promiseResolutionListeners).forEach((eventName) => {
          client.on(eventName, promiseResolutionListeners[eventName]);
        });
      });
    }
    exports.connectAsync = connectAsync;
    exports.default = connect;
  }
});

// node_modules/mqtt/build/mqtt.js
var require_mqtt2 = __commonJS({
  "node_modules/mqtt/build/mqtt.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReasonCodes = exports.KeepaliveManager = exports.UniqueMessageIdProvider = exports.DefaultMessageIdProvider = exports.Store = exports.MqttClient = exports.connectAsync = exports.connect = exports.Client = void 0;
    var client_1 = __importDefault(require_client());
    exports.MqttClient = client_1.default;
    var default_message_id_provider_1 = __importDefault(require_default_message_id_provider());
    exports.DefaultMessageIdProvider = default_message_id_provider_1.default;
    var unique_message_id_provider_1 = __importDefault(require_unique_message_id_provider());
    exports.UniqueMessageIdProvider = unique_message_id_provider_1.default;
    var store_1 = __importDefault(require_store());
    exports.Store = store_1.default;
    var connect_1 = __importStar(require_connect());
    exports.connect = connect_1.default;
    Object.defineProperty(exports, "connectAsync", { enumerable: true, get: function() {
      return connect_1.connectAsync;
    } });
    var KeepaliveManager_1 = __importDefault(require_KeepaliveManager());
    exports.KeepaliveManager = KeepaliveManager_1.default;
    exports.Client = client_1.default;
    __exportStar(require_client(), exports);
    __exportStar(require_shared(), exports);
    var ack_1 = require_ack();
    Object.defineProperty(exports, "ReasonCodes", { enumerable: true, get: function() {
      return ack_1.ReasonCodes;
    } });
  }
});

// node_modules/mqtt/build/index.js
var require_build = __commonJS({
  "node_modules/mqtt/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var mqtt2 = __importStar(require_mqtt2());
    exports.default = mqtt2;
    __exportStar(require_mqtt2(), exports);
  }
});

// src/analysis/sendCommandNowNew.ts
var sendCommandNowNew_exports = {};
__export(sendCommandNowNew_exports, {
  default: () => sendCommandNowNew_default,
  sendCommand: () => sendCommand
});
var import_sdk = require("@tago-io/sdk");
var import_mqtt = __toESM(require_build());
var brokerUrl = "mqtt://34.67.184.199:1883";
var clientId = "publisher-client";
async function sendCommand(context, scope) {
  console.log("Running Analysis");
  console.log(scope);
  const output_select = scope.find((x) => x.variable === "output_select")?.value;
  const output_status = scope.find((x) => x.variable === "output_status")?.value;
  const output_time = scope.find((x) => x.variable === "output_time")?.value;
  if (!output_time) {
    return;
  }
  const time_splitted = String(output_time).split(":");
  const array_time = [Number(time_splitted[0]), Number(time_splitted[1])];
  const group = scope[0].device;
  const token = context.token;
  const resources = new import_sdk.Resources({ token });
  const device_info = await resources.devices.info(group);
  const serial_id = device_info.tags.find((x) => x.key === "serial_number")?.value;
  const client = import_mqtt.default.connect(brokerUrl, { clientId });
  client.on("connect", () => {
    console.log(`Cliente ${clientId} conectado ao broker.`);
    const message = {
      "SN": serial_id,
      "data": {
        "Out": {
          "output": output_select,
          "status": output_status,
          "outTime": array_time
        }
      }
    };
    console.log(JSON.stringify(message));
    client.publish("downlink", JSON.stringify(message), {}, (err) => {
      if (err) {
        console.error("Erro ao publicar:", err);
      } else {
        console.log(`Mensagem publicada no t\xF3pico "downlink": ${message}`);
      }
      client.end();
    });
  });
  client.on("error", (err) => {
    console.error("Erro de conex\xE3o:", err);
  });
}
var sendCommandNowNew_default = new import_sdk.Analysis(sendCommand, { token: "a-84094b8e-b781-49ef-90f9-c505ad3978a4" });
module.exports = __toCommonJS(sendCommandNowNew_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  sendCommand
});
